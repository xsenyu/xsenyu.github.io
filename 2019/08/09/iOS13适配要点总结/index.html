<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="senyu">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" type="image/ico" href="favicon.ico"/>
  
  <title>
    
      iOS 13 适配要点总结 | Senyu&#39;s blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Senyu's blog" type="application/atom+xml">
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Senyu's blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>iOS 13 适配要点总结</h2>
  <p class="post-date">2019-08-09</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>本文在 <a href="https://juejin.im/user/5d8af836518825093a357646/posts" target="_blank" rel="noopener">掘金</a> 也持续更新。</p>
<h2 id="iOS-13-支持适配的机型"><a href="#iOS-13-支持适配的机型" class="headerlink" title="iOS 13 支持适配的机型"></a>iOS 13 支持适配的机型</h2><ul>
<li>iPhone 11、iPhone 11 Pro、iPhone 11 Pro Max</li>
<li>iPhone X、iPhone XR、iPhone XS、iPhone XS Max</li>
<li>iPhone 8、iPhone 8 Plus</li>
<li>iPhone 7、iPhone 7 Plus</li>
<li>iPhone 6s、iPhone 6s Plus</li>
<li>iPhone SE</li>
<li>iPod touch (第七代)</li>
<li>后续发布的新版本 iPhone</li>
</ul>
<h2 id="适配时间节点要求"><a href="#适配时间节点要求" class="headerlink" title="适配时间节点要求"></a>适配时间节点要求</h2><blockquote>
<p>2019 年 11 月 5 日</p>
</blockquote>
<p>苹果在当天正式弃用 <code>Xcode 11.2</code> 版本，需要更新至 <code>Xcode 11.2.1</code> 或之后的版本进行打包提审。</p>
<blockquote>
<p>2020 年 6 月 30 日</p>
</blockquote>
<p><em>苹果在 2020.03.26 延迟了适配的时间节点，可见 <a href="https://developer.apple.com/news/?id=03262020b" target="_blank" rel="noopener">Deadline for App Updates has Been Extended
</a></em></p>
<ol>
<li>所有提交到 <code>AppStore</code> 的新应用和应用更新必须使用 <code>iOS 13</code> 的 SDK 进行<strong>编译打包</strong>。并支持所有对应所有设备的屏幕尺寸，详请可见 <a href="https://developer.apple.com/news/?id=03042020b" target="_blank" rel="noopener">Submit Your iPhone Apps to the App Store
</a> 以及 <a href="https://developer.apple.com/news/?id=03042020c" target="_blank" rel="noopener">Submit Your iPad Apps to the App Store
</a> ；</li>
<li>所有应用必须使用 <code>Xcode</code> <code>storyboard</code> 提供支持所有屏幕尺寸的<strong>启动界面</strong>，详请可见 <a href="https://developer.apple.com/news/?id=01132020b" target="_blank" rel="noopener">Building Adaptive User Interfaces for iPhone and iPad</a>;</li>
<li><strong>现有</strong>的应用和应用中，更新符合苹果审核规则中关于接入 <code>Sign In With Apple</code> 功能要求的必须进行接入 ，具体要求可以见下文内容。</li>
<li>所有 AppWatch 应用必须使用 <code>watchOS 6</code> 或之后版本的 SDK 进行<strong>编译打包</strong>。</li>
<li>Kids category 中的应用必须符合审核指南中的 guideline 1.3 、guideline 5.1.4。</li>
<li>使用 HTML 5 的应用必须符合审核指南的 guideline 4.7 sections 4, 5, and 6。</li>
</ol>
<blockquote>
<p>2020 年 4 月</p>
</blockquote>
<p><strong>新应用</strong>必须使用 <code>WKWebView</code> 代替 <code>UIWebView</code>，详请可见 <a href="https://developer.apple.com/news/?id=12232019b" target="_blank" rel="noopener">Updating Apps that Use Web Views</a>；</p>
<blockquote>
<p>2020 年 12 月</p>
</blockquote>
<p><strong>应用更新</strong>必须使用 <code>WKWebView</code> 代替 <code>UIWebView</code>，详请可见 <a href="https://developer.apple.com/news/?id=12232019b" target="_blank" rel="noopener">Updating Apps that Use Web Views</a>；</p>
<h2 id="新特性适配"><a href="#新特性适配" class="headerlink" title="新特性适配"></a>新特性适配</h2><h3 id="1-Dark-Mode"><a href="#1-Dark-Mode" class="headerlink" title="1. Dark Mode"></a>1. Dark Mode</h3><p>iOS 13 推出暗黑模式，<code>UIKit</code> 提供新的系统颜色和 api 来适配不同颜色模式，<code>xcassets</code> 对素材适配也做了调整，具体适配可见: <a href="https://developer.apple.com/videos/play/wwdc2019/214/" target="_blank" rel="noopener">Implementing Dark Mode on iOS</a>。</p>
<p>Dark Mode 不是必须适配，但前提是你需要确保应用在切换主题后不会影响到用户使用（比如说文字和背景颜色相同可能会影响使用）。如果不打算适配 Dark Mode，可以直接在 <code>Info.plist</code> 中添加一栏：<code>User Interface Style</code> : <code>Light</code>，即可在应用内禁用暗黑模式。</p>
<p>另外，即使设置了颜色方案，申请权限的系统弹窗还是会依据系统的颜色进行显示，自己创建的 <code>UIAlertController</code> 就不会。</p>
<h3 id="2-Sign-In-with-Apple"><a href="#2-Sign-In-with-Apple" class="headerlink" title="2. Sign In with Apple"></a>2. Sign In with Apple</h3><p>在 iOS 13 中苹果推出一种在 App 和网站上快速、便捷登录的方式: <a href="https://developer.apple.com/videos/play/wwdc2019/706/" target="_blank" rel="noopener">Sign In With Apple</a>。这是 iOS 13 新增的功能，因此需要使用 Xcode 11 进行开发。关于应用是否要求接入此登录方式，苹果在 <a href="https://developer.apple.com/app-store/review/guidelines/#sign-in-with-apple" target="_blank" rel="noopener">App Store 应用审核指南</a> 中提到：</p>
<blockquote>
<p>Apps that exclusively use a third-party or social login service (such as Facebook Login, Google Sign-In, Sign in with Twitter, Sign In with LinkedIn, Login with Amazon, or WeChat Login) to set up or authenticate the user’s primary account with the app must also offer Sign in with Apple as an equivalent option. </p>
</blockquote>
<p>如果你的应用使用了<strong>第三方或社交账号登录服务</strong>（如Facebook、Google、Twitter、LinkedIn、Amazon、微信等）来设置或验证用户的主账号，就必须把 <code>Sign In With Apple</code> 作为同等的选项添加到应用上。如果是下面这些类型的应用则<strong>不需要</strong>添加：</p>
<ul>
<li><strong>仅仅</strong>使用公司<strong>内部账号</strong>来注册和登录的应用；</li>
<li>要求用户使用<strong>现有的</strong>教育或企业账号进行登录的教育、企业或商务类型的应用；</li>
<li>使用<strong>政府或业界支持</strong>的公民身份识别系统或电子标识对用户进行身份验证的应用；</li>
<li>特定第三方服务的应用，用户需要直接登录其邮箱、社交媒体或其他第三方帐户才能访问其内容。</li>
</ul>
<p>另外需要注意，关于何时要求接入 <code>Sign In With Apple</code>，苹果在 <a href="https://developer.apple.com/news/" target="_blank" rel="noopener">News and Updates</a> 中提到：</p>
<blockquote>
<p>Starting today, new apps submitted to the App Store must follow these guidelines. Existing apps and app updates must follow them by April 2020. </p>
</blockquote>
<p>2019 年 9 月 12 日 起，提交到 App Store 的<strong>新应用</strong>必须按照应用审核指南中的标准进行接入；<strong>现有</strong>应用和应用更新必须也在 2020 年 4 月前完成接入。</p>
<h2 id="API-适配"><a href="#API-适配" class="headerlink" title="API 适配"></a>API 适配</h2><h3 id="1-私有方法-KVC-可能导致崩溃"><a href="#1-私有方法-KVC-可能导致崩溃" class="headerlink" title="1. 私有方法 KVC 可能导致崩溃"></a>1. <span id="api">私有方法 KVC 可能导致崩溃</span></h3><p>在 iOS 13 中<strong>部分</strong>方法属性不允许使用 <code>valueForKey</code>、<code>setValue:forKey:</code>  来获取或者设置私有属性，具体表现为在运行时会直接崩溃，并提示以下崩溃信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*** Terminating app due to uncaught exception &#39;NSGenericException&#39;, reason: &#39;Access to UISearchBar&#39;s _searchField ivar is prohibited. This is an application bug&#39;</span><br></pre></td></tr></table></figure>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>目前整理的会导致崩溃的私有 api 和对应替代方案如下，感谢 <a href="https://juejin.im/user/57ad34026be3ff006b91c1f3" target="_blank" rel="noopener">@君赏</a> 的反馈，也欢迎各位大佬补充和指正 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 崩溃 api</span><br><span class="line">UITextField *textField &#x3D; [searchBar valueForKey:@&quot;_searchField&quot;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 替代方案 1，使用 iOS 13 的新属性 searchTextField</span><br><span class="line">searchBar.searchTextField.placeholder &#x3D; @&quot;search&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 替代方案 2，遍历获取指定类型的属性</span><br><span class="line">- (UIView *)findViewWithClassName:(NSString *)className inView:(UIView *)view&#123;</span><br><span class="line">    Class specificView &#x3D; NSClassFromString(className);</span><br><span class="line">    if ([view isKindOfClass:specificView]) &#123;</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (view.subviews.count &gt; 0) &#123;</span><br><span class="line">        for (UIView *subView in view.subviews) &#123;</span><br><span class="line">            UIView *targetView &#x3D; [self findViewWithClassName:className inView:subView];</span><br><span class="line">            if (targetView !&#x3D; nil) &#123;</span><br><span class="line">                return targetView;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用方法</span><br><span class="line"> UITextField *textField &#x3D; [self findViewWithClassName:@&quot;UITextField&quot; inView:_searchBar];</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 崩溃 api</span><br><span class="line">[searchBar setValue:@&quot;取消&quot; forKey:@&quot;_cancelButtonText&quot;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 替代方案，用同上的方法找到子类中 UIButton 类型的属性，然后设置其标题</span><br><span class="line">UIButton *cancelButton &#x3D; [self findViewWithClassName:NSStringFromClass([UIButton class]) inView:searchBar];</span><br><span class="line">[cancelButton setTitle:@&quot;取消&quot; forState:UIControlStateNormal];</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 崩溃 api。获取 _placeholderLabel 不会崩溃，但是获取 _placeholderLabel 里的属性就会</span><br><span class="line">[textField setValue:[UIColor blueColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];</span><br><span class="line">[textField setValue:[UIFont systemFontOfSize:20] forKeyPath:@&quot;_placeholderLabel.font&quot;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 替代方案 1，去掉下划线，访问 placeholderLabel</span><br><span class="line">[textField setValue:[UIColor blueColor] forKeyPath:@&quot;placeholderLabel.textColor&quot;];</span><br><span class="line">[textField setValue:[UIFont systemFontOfSize:20] forKeyPath:@&quot;placeholderLabel.font&quot;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 替代方案 2</span><br><span class="line">textField.attributedPlaceholder &#x3D; [[NSAttributedString alloc] initWithString:@&quot;输入&quot; attributes:@&#123;</span><br><span class="line">    NSForegroundColorAttributeName: [UIColor blueColor],</span><br><span class="line">    NSFontAttributeName: [UIFont systemFontOfSize:20]</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>


<h3 id="2-推送的-deviceToken-获取到的格式发生变化"><a href="#2-推送的-deviceToken-获取到的格式发生变化" class="headerlink" title="2. 推送的 deviceToken 获取到的格式发生变化"></a>2. 推送的 deviceToken 获取到的格式发生变化</h3><p>原本可以直接将 <code>NSData</code> 类型的 <code>deviceToken</code> 转换成 <code>NSString</code> 字符串，然后替换掉多余的符号即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken &#123;</span><br><span class="line">    NSString *token &#x3D; [deviceToken description];</span><br><span class="line">    for (NSString *symbol in @[@&quot; &quot;, @&quot;&lt;&quot;, @&quot;&gt;&quot;, @&quot;-&quot;]) &#123;</span><br><span class="line">        token &#x3D; [token stringByReplacingOccurrencesOfString:symbol withString:@&quot;&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;deviceToken:%@&quot;, token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 iOS 13 中，这种方法已经失效，<code>NSData</code>类型的 deviceToken 转换成的字符串变成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;length &#x3D; 32, bytes &#x3D; 0xd7f9fe34 69be14d1 fa51be22 329ac80d ... 5ad13017 b8ad0736 &#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>需要进行一次数据格式处理，<a href="https://developer.umeng.com/docs/66632/detail/126489" target="_blank" rel="noopener">友盟</a>提供了一种做法，可以适配新旧系统：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;arpa&#x2F;inet.h&gt;</span><br><span class="line">- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken &#123;</span><br><span class="line">    if (![deviceToken isKindOfClass:[NSData class]]) return;</span><br><span class="line">    const unsigned *tokenBytes &#x3D; [deviceToken bytes];</span><br><span class="line">    &#x2F;&#x2F; 数据格式处理</span><br><span class="line">    NSString *hexToken &#x3D; [NSString stringWithFormat:@&quot;%08x%08x%08x%08x%08x%08x%08x%08x&quot;,</span><br><span class="line">                          ntohl(tokenBytes[0]), ntohl(tokenBytes[1]), ntohl(tokenBytes[2]),</span><br><span class="line">                          ntohl(tokenBytes[3]), ntohl(tokenBytes[4]), ntohl(tokenBytes[5]),</span><br><span class="line">                          ntohl(tokenBytes[6]), ntohl(tokenBytes[7])];</span><br><span class="line">    NSLog(@&quot;deviceToken:%@&quot;, hexToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是注意到这种方法限定了长度，而<a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622958-application?language=objc" target="_blank" rel="noopener">官网文档</a>对此方法的说明中提到，<em>APNs device tokens are of variable length. Do not hard-code their size.</em> ，因此可以对数据格式处理部分进行优化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken &#123;</span><br><span class="line">    if (![deviceToken isKindOfClass:[NSData class]]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    const unsigned char *tokenBytes &#x3D; deviceToken.bytes; </span><br><span class="line">    NSInteger count &#x3D; deviceToken.length;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 数据格式处理</span><br><span class="line">    NSMutableString *hexToken &#x3D; [NSMutableString string];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; count; ++i) &#123;</span><br><span class="line">        [hexToken appendFormat:@&quot;%02x&quot;, tokenBytes[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;deviceToken:%@&quot;, hexToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-模态视图的默认样式发生改变"><a href="#3-模态视图的默认样式发生改变" class="headerlink" title="3. 模态视图的默认样式发生改变"></a>3. <span id="present">模态视图的默认样式发生改变</span></h3><p>在 iOS 13，使用 <code>presentViewController</code> 方式打开模态视图，默认的如下图所示的视差效果，通过下滑返回。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/25/16d66db07ffd0894?w=300&h=620&f=gif&s=472271" alt="UIModalPresentationAutomatic"></p>
<p>这是因为苹果将 <code>UIViewController</code> 的 <code>modalPresentationStyle</code> 属性的默认值改成了新加的一个枚举值  <a href="https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/uimodalpresentationautomatic?language=objc" target="_blank" rel="noopener">UIModalPresentationAutomatic</a>，对于多数 <code>UIViewController</code>，此值会映射成 <code>UIModalPresentationPageSheet</code>。</p>
<p>需要注意，这种效果弹出来的页面导航栏部分是会被砍掉的，在 storyboard 中也可以看到，页面布局时需要注意导航栏的内容不要被遮挡。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/25/16d66db08020a579?w=300&h=221&f=png&s=49603" alt="Storyboard"></p>
<p>还有一点注意的是，我们原来以全屏的样式弹出一个页面，那么将这个页面弹出的那个 ViewController 会依次调用 <code>viewWillDisappear</code> 和 <code>viewDidDisappear</code>。然后在这个页面被 dismiss 的时候，将他弹出的那个 ViewController 的 <code>viewWillAppear</code> 和 <code>viewDidAppear</code> 会被依次调用。然而使用默认的视差效果弹出页面，将他弹出的那个 ViewController 并不会调用这些方法，原先写在这四个函数中的代码以后都有可能会存在问题。</p>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>如果视差效果的样式可以接受的话，就不需要修改；如果需要改回全屏显示的界面，需要手动设置弹出样式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (UIModalPresentationStyle)modalPresentationStyle &#123;</span><br><span class="line">    return UIModalPresentationFullScreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-UISearchBar-黑线处理导致崩溃"><a href="#4-UISearchBar-黑线处理导致崩溃" class="headerlink" title="4. UISearchBar 黑线处理导致崩溃"></a>4. UISearchBar 黑线处理导致崩溃</h3><p>之前为了处理搜索框的黑线问题，通常会遍历 searchBar 的 subViews，找到并删除 <code>UISearchBarBackground</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (UIView *view in _searchBar.subviews.lastObject.subviews) &#123;</span><br><span class="line">    if ([view isKindOfClass:NSClassFromString(@&quot;UISearchBarBackground&quot;)]) &#123;</span><br><span class="line">        [view removeFromSuperview];</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 iOS13 中这么做会导致 UI 渲染失败，然后直接崩溃，崩溃信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*** Terminating app due to uncaught exception &#39;NSInternalInconsistencyException&#39;, reason: &#39;Missing or detached view for search bar layout&#39;</span><br></pre></td></tr></table></figure>
<h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><p>设置 <code>UISearchBar</code> 的背景图片为空:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_searchBar setBackgroundImage:[UIImage new]];</span><br></pre></td></tr></table></figure>
<h3 id="5-UITabBarButton-不同状态下结构不同"><a href="#5-UITabBarButton-不同状态下结构不同" class="headerlink" title="5. UITabBarButton 不同状态下结构不同"></a>5. UITabBarButton 不同状态下结构不同</h3><p>在 iOS 13 中，<code>UITabBarButton</code> 的控件结构会随着其选中状态的变化而变化，主要体现为 <code>UITabBarSwappableImageView</code> 和 <code>UITabBarButtonLabel</code> 的位置变化。在选中时和以前一样，是 <code>UITabBarButton</code> 的子控件。而在未选中状态下放到了 <code>UIVisualEffectView</code> 的 <code>_UIVisualEffectContentView</code> 里面。感谢<a href="https://juejin.im/user/5b8732a251882542ec199ec8" target="_blank" rel="noopener">@关灯侠</a>的提醒，具体可以看下图的对比：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/9/16daf5e8a8c46820?w=300&h=203&f=png&s=95716" alt="UITabBarButton"></p>
<p>我们在自定义 <code>UITabBar</code> 时，通常会遍历 <code>UITabBarButton</code> 的子控件获取 <code>UITabBarSwappableImageView</code>，比如自定义红点时添加到这个 ImageView 的右上角，这在 iOS 13 中可能就会导致异常。</p>
<h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><p>可以使用递归遍历 <code>UITabBarButton</code> 的所有 subviews 获取 <code>UITabBarSwappableImageView</code>，具体可以参照上面 <a href="#api">私有方法 KVC 可能导致崩溃</a> 章节中给出的递归遍历方法。</p>
<p>另外需要注意，未选中状态下，添加的红点会和 tabBar 的图片一样变成灰色，这一点应该也是因为其结构变化造成的。具体可以见下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/9/16daf8347a6c5949?w=300&h=55&f=png&s=5354" alt="UITabBar color"></p>
<p>如果想要和以前一样未选中时也是红色，也很简单，把红点添加到 <code>UITabBarButton</code> 上，位置再根据 <code>UITabBarSwappableImageView</code> 调整即可。</p>
<h3 id="6-UINavigationBar-设置按钮边距导致崩溃"><a href="#6-UINavigationBar-设置按钮边距导致崩溃" class="headerlink" title="6. UINavigationBar 设置按钮边距导致崩溃"></a>6. UINavigationBar 设置按钮边距导致崩溃</h3><p>从 iOS 11 开始，<code>UINavigationBar</code> 使用了自动布局，左右两边的按钮到屏幕之间会有 16 或 20 的边距。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/10/16db3abfd5976756?w=300&h=153&f=png&s=9504" alt="distance"><br>为了避免点击到间距的空白处没有响应，通常做法是：定义一个 <code>UINavigationBar</code> 子类，重写 <code>layoutSubviews</code> 方法，在此方法里遍历 subviews 获取 <code>_UINavigationBarContentView</code>，并将其 <code>layoutMargins</code> 设置为 <code>UIEdgeInsetsZero</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)layoutSubviews &#123;</span><br><span class="line">    [super layoutSubviews];</span><br><span class="line">    </span><br><span class="line">    for (UIView *subview in self.subviews) &#123;</span><br><span class="line">        if ([NSStringFromClass([subview class]) containsString:@&quot;_UINavigationBarContentView&quot;]) &#123;</span><br><span class="line">            subview.layoutMargins &#x3D; UIEdgeInsetsZero;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，这种做法在 iOS 13 中会导致崩溃，崩溃信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*** Terminating app due to uncaught exception &#39;NSInternalInconsistencyException&#39;, reason: &#39;Client error attempting to change layout margins of a private view&#39;</span><br></pre></td></tr></table></figure>
<h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用设置 frame 的方式，让 <code>_UINavigationBarContentView</code> 向两边伸展，从而抵消两边的边距。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)layoutSubviews &#123;</span><br><span class="line">    [super layoutSubviews];</span><br><span class="line">    </span><br><span class="line">    for (UIView *subview in self.subviews) &#123;</span><br><span class="line">        if ([NSStringFromClass([subview class]) containsString:@&quot;_UINavigationBarContentView&quot;]) &#123;</span><br><span class="line">            if ([UIDevice currentDevice].systemVersion.floatValue &gt;&#x3D; 13.0) &#123;</span><br><span class="line">                UIEdgeInsets margins &#x3D; subview.layoutMargins;</span><br><span class="line">                subview.frame &#x3D; CGRectMake(-margins.left, -margins.top, margins.left + margins.right + subview.frame.size.width, margins.top + margins.bottom + subview.frame.size.height);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                subview.layoutMargins &#x3D; UIEdgeInsetsZero;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-子线程修改界面导致崩溃（相册首次授权回调必现）"><a href="#7-子线程修改界面导致崩溃（相册首次授权回调必现）" class="headerlink" title="7. 子线程修改界面导致崩溃（相册首次授权回调必现）"></a>7. 子线程修改界面导致崩溃（相册首次授权回调必现）</h3><p>在使用相册时我们会调用 <code>[PHPhotoLibrary requestAuthorization:]</code> 方法获取权限，获取的结果会通过一个带有 <code>PHAuthorizationStatus</code> 信息的 block 进行回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[PHPhotoLibrary requestAuthorization:^(PHAuthorizationStatus status) &#123;</span><br><span class="line">    &#x2F;&#x2F; 根据 status 判断不同状态</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>根据 <a href="https://juejin.im/user/5c7c90c66fb9a049d132dcb9" target="_blank" rel="noopener">@路随心生</a> 的反馈，在 iOS 13 中，如果在第一次获取权限的回调中直接修改界面，会导致崩溃，崩溃信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This application is modifying the autolayout engine from a background thread after the engine was accessed from the main thread. This can lead to engine corruption and weird crashes.</span><br><span class="line"></span><br><span class="line">*** Terminating app due to uncaught exception &#39;NSInternalInconsistencyException&#39;, reason: &#39;Modifications to the layout engine must not be performed from a background thread after it has been accessed from the main thread.&#39;</span><br></pre></td></tr></table></figure>

<p>实际测试，第一次授权崩溃必先，再次授权偶现。另外，正如崩溃信息所言，不只是相册授权回调线程，其他子线程修改界面都有一定概率导致崩溃，而在 iOS 13 中貌似概率更高。</p>
<h4 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h4><p>在 Xcode 中调试运行时，子线程修改界面会有紫色感叹号标出，注意修改成回到主线程即可。</p>
<h3 id="8-默认弹出样式打开的页面在-WKWebView-中获取照片崩溃"><a href="#8-默认弹出样式打开的页面在-WKWebView-中获取照片崩溃" class="headerlink" title="8. 默认弹出样式打开的页面在 WKWebView 中获取照片崩溃"></a>8. 默认弹出样式打开的页面在 WKWebView 中获取照片崩溃</h3><p>由于 iOS 13 中<a href="#present">模态视图的默认样式发生改变</a>，如果以默认的 <code>UIModalPresentationPageSheet</code> 样式弹出一个 ViewController，并使用 <code>WKWebView</code> 通过 HTML 获取系统照片：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_webView loadHTMLString:@&quot;&lt;input accept&#x3D;&#39;image&#x2F;*&#39; type&#x3D;&#39;file&#39;&gt;&quot; baseURL:nil];</span><br></pre></td></tr></table></figure>
<p>在点击选择按钮时，根据<a href="https://juejin.im/user/5a0a45fe51882578da0d605f" target="_blank" rel="noopener">@伤心的Easyman</a>的反馈，会出现崩溃，崩溃信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*** Terminating app due to uncaught exception &#39;NSGenericException&#39;, reason: &#39;Your application has presented a UIDocumentMenuViewController (&lt;UIDocumentMenuViewController: 0x101226860&gt;). In its current trait environment, the modalPresentationStyle of a UIDocumentMenuViewController with this style is UIModalPresentationPopover. You must provide location information for this popover through the view controller&#39;s popoverPresentationController. You must provide either a sourceView and sourceRect or a barButtonItem.  If this information is not known when you present the view controller, you may provide it in the UIPopoverPresentationControllerDelegate method -prepareForPopoverPresentation.&#39;</span><br></pre></td></tr></table></figure>
<p>具体原因是，点击获取系统照片时，会弹出一个模态视图的样式为 <code>UIModalPresentationPopover</code> 的 <code>UIDocumentMenuViewController</code>，这种样式下，如果其父 <code>UIViewController</code> 以非全屏方式 present 的，那么就需要像 iPad 一样指定其 <code>sourceView</code> 和 <code>sourceRect</code>，或者指定一个 <code>barButtonItem</code>，否则会出现上述崩溃。而使用 <code>UIModalPresentationFullScreen</code> 的方式弹出的话就不会有这个问题。</p>
<h4 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h4><p>第一种方法就是指定<code>sourceView</code>、<code>sourceRect</code>，<code>barButtonItem</code> 同理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)presentViewController:(UIViewController *)viewControllerToPresent animated:(BOOL)flag completion:(void (^)(void))completion &#123;</span><br><span class="line">    [self setUIDocumentMenuViewControllerSoureViewsIfNeeded:viewControllerToPresent];</span><br><span class="line">    [super presentViewController:viewControllerToPresent animated:flag completion:completion];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setUIDocumentMenuViewControllerSoureViewsIfNeeded:(UIViewController *)viewControllerToPresent&#123;</span><br><span class="line">    if (@available(iOS 13, *)) &#123;</span><br><span class="line">        if([UIDevice currentDevice].userInterfaceIdiom &#x3D;&#x3D; UIUserInterfaceIdiomPhone &amp;&amp; [viewControllerToPresent isKindOfClass:UIDocumentMenuViewController.class])&#123;</span><br><span class="line">            viewControllerToPresent.popoverPresentationController.sourceView &#x3D; self.webView;</span><br><span class="line">            viewControllerToPresent.popoverPresentationController.sourceRect &#x3D; CGRectMake(15, 5, 1, 1); &#x2F;&#x2F; 具体看按钮的位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果顶层有 UINavigationController 的话，需要如下指定</span><br><span class="line">- (void)presentViewController:(UIViewController *)viewControllerToPresent animated:(BOOL)flag completion:(void (^)(void))completion &#123;</span><br><span class="line">    if([self.viewControllers.lastObject isKindOfClass:WKWebViewController.class])&#123;</span><br><span class="line">        WKWebViewController *vc &#x3D; self.viewControllers.lastObject;</span><br><span class="line">        [vc setUIDocumentMenuViewControllerSoureViewsIfNeeded:viewControllerToPresent];</span><br><span class="line">    &#125;</span><br><span class="line">    [super presentViewController:viewControllerToPresent animated:flag completion:completion];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方法就是使用全屏的方式弹出（实践证明默认弹出样式在横屏下是全屏的不会崩）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (UIModalPresentationStyle)modalPresentationStyle &#123;</span><br><span class="line">    return UIModalPresentationFullScreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-WKWebView-在-iPad-上默认显示桌面版的网页"><a href="#9-WKWebView-在-iPad-上默认显示桌面版的网页" class="headerlink" title="9. WKWebView 在 iPad 上默认显示桌面版的网页"></a>9. WKWebView 在 iPad 上默认显示桌面版的网页</h3><p>在 iPadOS 上，使用 <code>WKWebView</code> 打开网页默认使用桌面版的网页，抓包发现其默认的 UserAgent 变成了 Desktop 版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15) AppleWebKit&#x2F;605.1.15 (KHTML, like Gecko)</span><br></pre></td></tr></table></figure>
<p>原因是苹果在 iOS 13.0 中为 <code>WKWebView</code> 添加了切换桌面版本和手机版本的方法，其通过在一个新加的枚举值控制:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, WKContentMode) &#123;</span><br><span class="line">    WKContentModeRecommended,</span><br><span class="line">    WKContentModeMobile,</span><br><span class="line">    WKContentModeDesktop</span><br><span class="line">&#125; API_AVAILABLE(ios(13.0));</span><br></pre></td></tr></table></figure>
<p>此枚举默认值为 <code>WKContentModeRecommended</code>，在 iPhone 和 iPad mini 上映射为 <code>WKContentModeMobile</code>，在其他 iPad 上则为 <code>WKContentModeDesktop</code>，因此 iPad 上打开网页默认显示桌面版本。</p>
<h4 id="解决方案-8"><a href="#解决方案-8" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li>可通过 <code>WKWebViewConfiguration</code> 的新属性 <a href="https://developer.apple.com/documentation/webkit/wkwebviewconfiguration/3194420-defaultwebpagepreferences?language=objc" target="_blank" rel="noopener">defaultWebpagePreferences</a> 来设置，目前其仅包含一个 <code>WKContentMode</code> 类型的属性 <a href="https://developer.apple.com/documentation/webkit/wkwebpagepreferences/3194426-preferredcontentmode?language=objc" target="_blank" rel="noopener">preferredContentMode</a>，默认值为 <code>WKContentModeRecommended</code> 可以通过改变其值来修改显示的版本:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WKWebViewConfiguration *configuration &#x3D; [[WKWebViewConfiguration alloc] init];</span><br><span class="line">if (@available(iOS 13.0, *)) &#123;</span><br><span class="line">    configuration.defaultWebpagePreferences.preferredContentMode &#x3D; WKContentModeMobile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>除了在初始化时候设置外，还可以通过新的代理方法实现桌面版和移动版切换，苹果给出了一个具体的例子: <a href="https://developer.apple.com/documentation/webkit/viewing_desktop_or_mobile_web_content_using_a_web_view" target="_blank" rel="noopener">Viewing Desktop or Mobile Web Content Using a Web View</a>，其中关键的方法为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction preferences:(WKWebpagePreferences *)preferences decisionHandler:(void (^)(WKNavigationActionPolicy, WKWebpagePreferences * _Nonnull))decisionHandler &#123;</span><br><span class="line">    preferences.preferredContentMode &#x3D; WKContentModeMobile;</span><br><span class="line">    decisionHandler(WKNavigationActionPolicyAllow, preferences);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="方法弃用"><a href="#方法弃用" class="headerlink" title="方法弃用"></a>方法弃用</h2><h3 id="1-UIWebView-将被禁止提交审核"><a href="#1-UIWebView-将被禁止提交审核" class="headerlink" title="1. UIWebView 将被禁止提交审核"></a>1. UIWebView 将被禁止提交审核</h3><p>在 iOS 13 推出后，苹果在 <a href="https://developer.apple.com/documentation/uikit/uiwebview?language=objc" target="_blank" rel="noopener">UIWebView</a> 的说明上将其支持的系统范围定格在了 iOS 2 ~ iOS 12。在 2019 年 12 月 23 日更新的 <a href="https://developer.apple.com/news/?id=12232019b" target="_blank" rel="noopener">News and Updates</a>中，苹果给出了确切的时间节点：</p>
<blockquote>
<p>The App Store will no longer accept new apps using UIWebView as of April 2020 and app updates using UIWebView as of December 2020.</p>
</blockquote>
<p>2020 年 4 月开始不再接受包含 UIWebView 的<strong>新应用</strong>提交，2020 年 12 月开始不再接受包含 UIWebView 的<strong>应用更新</strong>提交。</p>
<h4 id="解决方案-9"><a href="#解决方案-9" class="headerlink" title="解决方案"></a>解决方案</h4><p>用 <code>WKWebView</code> 替代 <code>UIWebView</code>，确保所有 <code>UIWebView</code> 的 api 都要移除，如果需要适配 iOS 7 的可以通过 <code>openURL</code> 的方式在 <code>Safari</code> 打开。</p>
<h3 id="2-使用-UISearchDisplayController-导致崩溃"><a href="#2-使用-UISearchDisplayController-导致崩溃" class="headerlink" title="2. 使用 UISearchDisplayController 导致崩溃"></a>2. 使用 UISearchDisplayController 导致崩溃</h3><p>在 iOS 8 之前，我们在 <code>UITableView</code> 上添加搜索框需要使用 <code>UISearchBar</code> + <code>UISearchDisplayController</code> 的组合方式，而在 iOS 8 之后，苹果就已经推出了 <code>UISearchController</code> 来代替这个组合方式。在 iOS 13 中，如果还继续使用 <code>UISearchDisplayController</code> 会直接导致崩溃，崩溃信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*** Terminating app due to uncaught exception &#39;NSGenericException&#39;, reason: &#39;UISearchDisplayController is no longer supported when linking against this version of iOS. Please migrate your application to UISearchController.&#39;</span><br></pre></td></tr></table></figure>
<h4 id="解决方案-10"><a href="#解决方案-10" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用 <code>UISearchController</code> 替换 <code>UISearchBar</code> + <code>UISearchDisplayController</code> 的组合方案。</p>
<h3 id="3-MPMoviePlayerController-被弃用"><a href="#3-MPMoviePlayerController-被弃用" class="headerlink" title="3. MPMoviePlayerController 被弃用"></a>3. MPMoviePlayerController 被弃用</h3><p>在 iOS 9 之前播放视频可以使用 <code>MediaPlayer.framework</code> 中的MPMoviePlayerController类来完成，它支持本地视频和网络视频播放。但是在 iOS 9 开始被弃用，如果在 iOS 13 中继续使用的话会直接抛出异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;MPMoviePlayerController is no longer available. Use AVPlayerViewController in AVKit.&#39;</span><br></pre></td></tr></table></figure>
<h4 id="解决方案-11"><a href="#解决方案-11" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用 <code>AVFoundation</code> 里的 <code>AVPlayer</code> 作为视频播放控件。</p>
<h2 id="工程适配"><a href="#工程适配" class="headerlink" title="工程适配"></a>工程适配</h2><h3 id="1-蓝牙权限字段更新导致崩溃以及提交审核失败"><a href="#1-蓝牙权限字段更新导致崩溃以及提交审核失败" class="headerlink" title="1. 蓝牙权限字段更新导致崩溃以及提交审核失败"></a>1. 蓝牙权限字段更新导致崩溃以及提交审核失败</h3><p>在 iOS 13 中，苹果将原来蓝牙申请权限用的 <a href="https://developer.apple.com/documentation/bundleresources/information_property_list/nsbluetoothperipheralusagedescription?language=objc" target="_blank" rel="noopener">NSBluetoothPeripheralUsageDescription</a> 字段，替换为 <a href="https://developer.apple.com/documentation/bundleresources/information_property_list/nsbluetoothalwaysusagedescription?language=objc" target="_blank" rel="noopener">NSBluetoothAlwaysUsageDescription</a> 字段。</p>
<blockquote>
<p>For apps with a deployment target of iOS 13 and later, use NSBluetoothAlwaysUsageDescription instead.</p>
</blockquote>
<p>感谢 <a href="https://juejin.im/user/590062eeda2f60005ddf10bd" target="_blank" rel="noopener">@dengChaoJie</a> 的反馈，如果在 iOS 13 中使用旧的权限字段获取蓝牙权限，会导致崩溃，崩溃信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This app has crashed because it attempted to access privacy-sensitive data without a usage description.  The app&#39;s Info.plist must contain an NSBluetoothAlwaysUsageDescription key with a string value explaining to the user how the app uses this data.</span><br></pre></td></tr></table></figure>
<p>另外，如果将没有新字段的包提交审核，将会收到包含 <code>ITMS-90683</code> 的邮件，并提示审核不通过。</p>
<blockquote>
<p>Dear Developer,</p>
<p>We identified one or more issues with a recent delivery for your app, “xxx”. Please correct the following issues, then upload again.</p>
<p>ITMS-90683: Missing Purpose String in Info.plist - Your app’s code references one or more APIs that access sensitive user data. The app’s Info.plist file should contain a NSBluetoothAlwaysUsageDescription key with a user-facing purpose string explaining clearly and completely why your app needs the data. Starting Spring 2019, all apps submitted to the App Store that access user data are required to include a purpose string. If you’re using external libraries or SDKs, they may reference APIs that require a purpose string. While your app might not use these APIs, a purpose string is still required. You can contact the developer of the library or SDK and request they release a version of their code that doesn’t contain the APIs. Learn more (<a href="https://developer.apple.com/documentation/uikit/core_app/protecting_the_user_s_privacy" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/core_app/protecting_the_user_s_privacy</a>).</p>
<p>Best regards,</p>
<p>The App Store Team</p>
</blockquote>
<h4 id="解决方案-12"><a href="#解决方案-12" class="headerlink" title="解决方案"></a>解决方案</h4><p>官网文档也有说明，就是在 Info.plist 中把两个字段都加上。</p>
<blockquote>
<p>For deployment targets earlier than iOS 13, add both NSBluetoothAlwaysUsageDescription and NSBluetoothPeripheralUsageDescription to your app’s Information Property List file. </p>
</blockquote>
<h3 id="2-CNCopyCurrentNetworkInfo-使用要求更严格"><a href="#2-CNCopyCurrentNetworkInfo-使用要求更严格" class="headerlink" title="2. CNCopyCurrentNetworkInfo 使用要求更严格"></a>2. CNCopyCurrentNetworkInfo 使用要求更严格</h3><p>从 iOS 12 开始，<code>CNCopyCurrentNetworkInfo</code> 函数需要开启 <a href="https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_developer_networking_wifi-info?language=objc" target="_blank" rel="noopener">Access WiFi Information</a> 的功能后才会返回正确的值。在 iOS 13 中，这个函数的使用要求变得更严格，根据 <a href="https://developer.apple.com/documentation/systemconfiguration/1614126-cncopycurrentnetworkinfo?language=occ" target="_blank" rel="noopener">CNCopyCurrentNetworkInfo</a> 文档说明，应用还需要符合下列三项条件中的至少一项才能得到正确的值：</p>
<ul>
<li>使用 <a href="https://developer.apple.com/documentation/corelocation?language=objc" target="_blank" rel="noopener">Core Location</a> 的应用， 并获得定位服务权限。</li>
<li>使用 <a href="https://developer.apple.com/documentation/networkextension/nehotspotconfiguration?language=objc" target="_blank" rel="noopener">NEHotspotConfiguration</a> 来配置 WiFi 网络的应用。</li>
<li>目前正处于启用状态的 VPN 应用。</li>
</ul>
<p>苹果作出这项改变主要为了保障用户的安全，因为根据 MAC 地址容易推算出用户当前所处的地理位置。同样，蓝牙设备也具有 MAC 地址，所以苹果也为蓝牙添加了新的权限，可见上一点。</p>
<h4 id="解决方案-13"><a href="#解决方案-13" class="headerlink" title="解决方案"></a>解决方案</h4><p>根据应用需求，添加三项要求其中一项。可以选择第一项获取定位权限，因为添加的成本不会太大，只需要用户允许应用使用定位服务即可。</p>
<h3 id="3-LaunchImage-被弃用"><a href="#3-LaunchImage-被弃用" class="headerlink" title="3. LaunchImage 被弃用"></a>3. LaunchImage 被弃用</h3><p>iOS 8 之前我们是在<code>LaunchImage</code> 来设置启动图，每当苹果推出新的屏幕尺寸的设备，我们需要 assets 里面放入对应的尺寸的启动图，这是非常繁琐的一个步骤。因此在 iOS 8 苹果引入了 <code>LaunchScreen</code>，可以直接在 Storyboard 上设置启动界面样式，可以很方便适配各种屏幕。</p>
<p>需要注意的是，苹果在 <a href="https://developer.apple.com/videos/play/wwdc2019/224/" target="_blank" rel="noopener">Modernizing Your UI for iOS 13</a>   section 中提到<br>，从2020年4月开始，所有支持 iOS 13 的 App 必须提供 <code>LaunchScreen.storyboard</code>，否则将无法提交到 App Store 进行审批。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/25/16d66db08104201c?w=300&h=219&f=png&s=22784" alt="Modernizing Your UI for iOS 13"></p>
<h4 id="解决方案-14"><a href="#解决方案-14" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用 <code>LaunchScreen.storyboard</code> 设置启动页，弃用 <code>LaunchImage</code>。</p>
<h3 id="4-UISegmentedControl-默认样式改变"><a href="#4-UISegmentedControl-默认样式改变" class="headerlink" title="4. UISegmentedControl 默认样式改变"></a>4. UISegmentedControl 默认样式改变</h3><p>默认样式变为白底黑字，如果设置修改过颜色的话，页面需要修改。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/25/16d66db081765de4?w=300&h=114&f=png&s=7081" alt="UISegmentedControl"></p>
<p>原本设置选中颜色的 <code>tintColor</code> 已经失效，新增了  <a href="https://developer.apple.com/documentation/uikit/uisegmentedcontrol/3335209-selectedsegmenttintcolor?language=objc" target="_blank" rel="noopener">selectedSegmentTintColor</a> 属性用以修改选中的颜色。</p>
<h3 id="5-Xcode-11-创建的工程在低版本设备上运行黑屏"><a href="#5-Xcode-11-创建的工程在低版本设备上运行黑屏" class="headerlink" title="5. Xcode 11 创建的工程在低版本设备上运行黑屏"></a>5. Xcode 11 创建的工程在低版本设备上运行黑屏</h3><p>使用 Xcode 11 创建的工程，运行设备选择 iOS 13.0 以下的设备，运行应用时会出现黑屏。这是因为 Xcode 11 默认是会创建通过 <code>UIScene</code> 管理多个 <code>UIWindow</code> 的应用，工程中除了 <code>AppDelegate</code> 外会多一个 <code>SceneDelegate</code>： </p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/25/16d66db082168a94" alt="Scene Delegate"></p>
<p>这是为了 iPadOS 的多进程准备的，也就是说 <code>UIWindow</code> 不再是 <code>UIApplication</code> 中管理，但是旧版本根本没有 <code>UIScene</code>。</p>
<h4 id="解决方案-15"><a href="#解决方案-15" class="headerlink" title="解决方案"></a>解决方案</h4><p>在 <code>AppDelegate</code> 的头文件加上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (strong, nonatomic) UIWindow *window;</span><br></pre></td></tr></table></figure>
<h3 id="6-Xcode-11-2-编译的工程在-iOS-13-2-之前版本的设备上会出现崩溃。"><a href="#6-Xcode-11-2-编译的工程在-iOS-13-2-之前版本的设备上会出现崩溃。" class="headerlink" title="6. Xcode 11.2 编译的工程在 iOS 13.2 之前版本的设备上会出现崩溃。"></a>6. Xcode 11.2 编译的工程在 iOS 13.2 之前版本的设备上会出现崩溃。</h3><p>如果工程的 <code>storyboard</code> 中包含 <code>UITextView</code>，并使用 Xcode 11.2 编译打包，那么 App 在 <code>iOS 13.2</code> 之前版本的设备会出现崩溃，崩溃信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*** Terminating app due to uncaught exception &#39;NSInvalidUnarchiveOperationException&#39;, reason: &#39;Could not instantiate class named _UITextLayoutView because no class named _UITextLayoutView was found; the class needs to be defined in source code or linked in from a library (ensure the class is part of the correct target)&#39;</span><br></pre></td></tr></table></figure>
<p>这个问题是 Xcode 的锅，苹果在此后紧急发布 Xcode 11.2.1 版本进行修复，Xcode 11.2 在 2019 年 11 月 5 日被正式弃用。目前如果仍然使用 Xcode 11.2 打包提审，会收到包含 <code>ERROR</code> <code>ITMS-90534</code> 和 <code>WARNING</code> <code>ITMS-90703</code> 的拒绝信息，相同案例可见 <a href="https://stackoverflow.com/questions/58748560/app-store-app-uploading-failed-with-error-itms-90534-and-warning-itms-90703" target="_blank" rel="noopener">stackoverflow</a>。</p>
<h4 id="解决方案-16"><a href="#解决方案-16" class="headerlink" title="解决方案"></a>解决方案</h4><p>更新至 Xcode 11.2.1 版本打包提审。</p>
<h2 id="SDK-适配"><a href="#SDK-适配" class="headerlink" title="SDK 适配"></a>SDK 适配</h2><h3 id="1-使用-available-导致旧版本-Xcode-编译出错"><a href="#1-使用-available-导致旧版本-Xcode-编译出错" class="headerlink" title="1.  使用 @available 导致旧版本 Xcode 编译出错"></a>1.  使用 <code>@available</code> 导致旧版本 Xcode 编译出错</h3><p>在 Xcode 11 的 SDK 工程的代码里面使用了 <code>@available</code> 判断当前系统版本，打出来的包放在 Xcode 10 中编译，会出现一下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Undefine symbols for architecture i386:</span><br><span class="line">    &quot;__isPlatformVersionAtLeast&quot;, referenced from:</span><br><span class="line">        ...</span><br><span class="line">ld: symbol(s) not found for architecture i386</span><br></pre></td></tr></table></figure>
<p>从错误信息来看，是 <code>__isPlatformVersionAtLeast</code> 方法没有具体的实现，但是工程里根本没有这个方法。实际测试无论在哪里使用<code>@available</code> ，并使用 Xcode 11 打包成动态库或静态库，把打包的库添加到 Xcode 10 中编译都会出现这个错误，因此可以判断是 iOS 13 的 <code>@available</code> 的实现中使用了新的 api。</p>
<h4 id="解决方案-17"><a href="#解决方案-17" class="headerlink" title="解决方案"></a>解决方案</h4><p>如果你的 SDK 需要适配旧版本的 Xcode，那么需要避开此方法，通过获取系统版本来进行判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ([UIDevice currentDevice].systemVersion.floatValue &gt;&#x3D; 13.0) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，在 Xcode 10 上打开 SDK 工程也应该可以正常编译，这就需要加上编译宏进行处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __IPHONE_13_0</span><br><span class="line">#define __IPHONE_13_0 130000</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;&#x3D; __IPHONE_13_0</span><br><span class="line">...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>本文结合个人遇到的问题和以下文章部分内容，对常见适配问题进行总结</p>
<ul>
<li><a href="https://www.jianshu.com/p/a0cc0f4e99c7" target="_blank" rel="noopener">iOS 13 适配</a></li>
<li><a href="https://www.jianshu.com/p/4654f8f6e16e" target="_blank" rel="noopener">iOS13适配</a></li>
<li><a href="https://blog.csdn.net/weixin_34258782/article/details/93169199" target="_blank" rel="noopener">适配 iOS13</a></li>
<li><a href="http://devhy.com/33-xcode11-and-ios13/" target="_blank" rel="noopener">Xcode11 和 iOS13 适配</a></li>
<li><a href="https://tomee.shop/ios13-adaptation/" target="_blank" rel="noopener">iOS13 UI &amp; 功能适配</a></li>
<li><a href="https://blog.csdn.net/qq_18683985/article/details/97374288" target="_blank" rel="noopener">解决Xcode11-beta版本新创建iOS工程低版本黑屏的问题</a></li>
<li><a href="https://xiaozhuanlan.com/topic/5671830492" target="_blank" rel="noopener">Modernizing Your UI for iOS13</a></li>
<li><a href="https://blog.cyaron.xyz/2019/08/01/cncopycurrentnetworkinfo-on-ios-13/" target="_blank" rel="noopener">CNCopyCurrentNetworkInfo 在 iOS 13 中的新特性以及 App 无法获取 Wi-Fi 信息的解决办法</a></li>
<li><a href="http://erichuang.top/2019/08/05/Objective-C/2019/iOS13%E9%80%82%E9%85%8D/" target="_blank" rel="noopener">iOS13适配</a></li>
</ul>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Technology" >
    <span class="tag-code">Technology</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2019/07/25/WWDC%202019%20Session%20302-%20In-App%20Purchases%20and%20Using%20Server-to-Server%20Notifications/">
        <span class="nav-arrow">← </span>
        
          WWDC 2019 Session 302 -- In-App Purchases and Using Server-to-Server Notifications
        
      </a>
    
    
      <a class="nav-right" href="/2019/11/14/%E5%9B%BE%E8%A7%A3%20TCP:IP%20%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/">
        
          《图解 TCP/IP》知识点整理
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://xsenyu.github.io/2019/08/09/iOS13适配要点总结/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2020 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Posted by <a href="">senyu</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>

  </body>
</html>